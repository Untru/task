Перем СтрокаПользователя;
Перем ТаблицаСтандартныхПериодов;
Перем МассивДаНет;


#Область ИнформацияОбОбработке

Функция СведенияОВнешнейОбработке() Экспорт
	// Объявим переменную, в которой мы сохраним и вернем "наружу" необходимые данные
	ПараметрыРегистрации = Новый Структура;
	
	// Объявим еще одну переменную, которая нам потребуется ниже
	МассивНазначений = Новый Массив;
	
	// Первый параметр, который мы должны указать - это какой вид обработки системе должна зарегистрировать. 
	// Допустимые типы: ДополнительнаяОбработка, ДополнительныйОтчет, ЗаполнениеОбъекта, Отчет, ПечатнаяФорма, СозданиеСвязанныхОбъектов
	ПараметрыРегистрации.Вставить("Вид", "ДополнительнаяОбработка");
	
	// Теперь нам необходимо передать в виде массива имен, к чему будет подключена наша ВПФ
	// Имейте ввиду, что можно задать имя в таком виде: Документ.* - в этом случае обработка будет подключена ко всем документам в системе, 
	// которые поддерживают механизм ВПФ
	//МассивНазначений.Добавить("Документ.ЗаказКлиента");
	//ПараметрыРегистрации.Вставить("Назначение", МассивНазначений);
	
	// Теперь зададим имя, под которым ВПФ будет зарегистрирована в справочнике внешних обработок
	ПараметрыРегистрации.Вставить("Наименование", "Телеграм бот");
	
	// Зададим право обработке на использование безопасного режима. Более подробно можно узнать в справке к платформе (метод УстановитьБезопасныйРежим)
	ПараметрыРегистрации.Вставить("БезопасныйРежим", Ложь);
	
	// Следующие два параметра играют больше информационную роль, т.е. это то, что будет видеть пользователь в информации к обработке
	ПараметрыРегистрации.Вставить("Версия", "1.0");    
	ПараметрыРегистрации.Вставить("Информация", "Телеграм бот предназначен для общения пользователей с базой 1С. Меню и дейстивия настраиваются пользователем. Конфигурация не изменяется (не снимается с поддержки)");
	
	ПараметрыРегистрации.Вставить("ВерсияБСП", "1.2.1.4");    
	
	// Создадим таблицу команд (подробнее смотрим ниже)
	ТаблицаКоманд = ПолучитьТаблицуКоманд();
	
	// Добавим команду в таблицу
	ДобавитьКоманду(ТаблицаКоманд, "Обработка запросов Телеграм бот", "ОбработкаЗапросов", "ВызовСерверногоМетода");
	
	ДобавитьКоманду(ТаблицаКоманд, "Форма настройки обработки запросов", "Форма", "ОткрытиеФормы");
	
	// Сохраним таблицу команд в параметры регистрации обработки
	ПараметрыРегистрации.Вставить("Команды", ТаблицаКоманд);
	
	// Теперь вернем системе наши параметры
	Возврат ПараметрыРегистрации;
КонецФункции

Функция ПолучитьТаблицуКоманд()
	
	// Создадим пустую таблицу команд и колонки в ней
	Команды = Новый ТаблицаЗначений;
	
	// Как будет выглядеть описание печатной формы для пользователя
	Команды.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка")); 
	
	// Имя нашего макета, что бы могли отличить вызванную команду в обработке печати
	Команды.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка"));
	
	// Тут задается, как должна вызваться команда обработки
	// Возможные варианты:
	// - ОткрытиеФормы - в этом случае в колонке идентификатор должно быть указано имя формы, которое должна будет открыть система
	// - ВызовКлиентскогоМетода - вызвать клиентскую экспортную процедуру из модуля формы обработки
	// - ВызовСерверногоМетода - вызвать серверную экспортную процедуру из модуля объекта обработки
	Команды.Колонки.Добавить("Использование", Новый ОписаниеТипов("Строка"));
	
	// Следующий параметр указывает, необходимо ли показывать оповещение при начале и завершению работы обработки. Не имеет смысла при открытии формы
	Команды.Колонки.Добавить("ПоказыватьОповещение", Новый ОписаниеТипов("Булево"));
	
	// Для печатной формы должен содержать строку ПечатьMXL 
	Команды.Колонки.Добавить("Модификатор", Новый ОписаниеТипов("Строка"));
	Возврат Команды;
КонецФункции

Процедура ДобавитьКоманду(ТаблицаКоманд, Представление, Идентификатор, Использование, ПоказыватьОповещение = Ложь, Модификатор = "")
	// Добавляем команду в таблицу команд по переданному описанию.
	// Параметры и их значения можно посмотреть в функции ПолучитьТаблицуКоманд
	НоваяКоманда = ТаблицаКоманд.Добавить();
	НоваяКоманда.Представление = Представление;
	НоваяКоманда.Идентификатор = Идентификатор;
	НоваяКоманда.Использование = Использование;
	НоваяКоманда.ПоказыватьОповещение = ПоказыватьОповещение;
	НоваяКоманда.Модификатор = Модификатор;
	
КонецПроцедуры

Процедура ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначенияМассив) Экспорт 
	
	ОбработкаЗапросов();
	
КонецПроцедуры

#КонецОбласти

#Область JSON

// 1С:JSON. JavaScript Object Notation парсер и сериализатор.

// Copyright © 2010-2013 Александр Переверзев

// Данная лицензия разрешает лицам, получившим копию данного программного 
// обеспечения и сопутствующей документации (в дальнейшем именуемыми «Программное 
// Обеспечение»), безвозмездно использовать Программное Обеспечение без ограничений, 
// включая неограниченное право на использование, копирование, изменение, 
// добавление, публикацию, распространение, сублицензирование и/или продажу копий 
// Программного Обеспечения, также как и лицам, которым предоставляется данное 
// Программное Обеспечение, при соблюдении следующих условий:

// Указанное выше уведомление об авторском праве и данные условия должны быть 
// включены во все копии или значимые части данного Программного Обеспечения.

// ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО 
// ГАРАНТИЙ, ЯВНО ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ 
// ГАРАНТИЯМИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО ЕГО КОНКРЕТНОМУ НАЗНАЧЕНИЮ И 
// ОТСУТСТВИЯ НАРУШЕНИЙ ПРАВ. НИ В КАКОМ СЛУЧАЕ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ 
// ОТВЕТСТВЕННОСТИ ПО ИСКАМ О ВОЗМЕЩЕНИИ УЩЕРБА, УБЫТКОВ ИЛИ ДРУГИХ ТРЕБОВАНИЙ ПО 
// ДЕЙСТВУЮЩИМ КОНТРАКТАМ, ДЕЛИКТАМ ИЛИ ИНОМУ, ВОЗНИКШИМ ИЗ, ИМЕЮЩИМ ПРИЧИНОЙ ИЛИ 
// СВЯЗАННЫМ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ ИЛИ ИСПОЛЬЗОВАНИЕМ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ 
// ИЛИ ИНЫМИ ДЕЙСТВИЯМИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.


// Александр Переверзев
// e-mail: a.v.pereverzev@gmail.com
// Версия: 2.0.0.17


// Особенности:
//	Парсер и сериализатор поддерживают два режима (формата) работы:
//		- Стандартный – полная поддержка стандарта JSON (подробнее см. <http://www.JSON.org/> и 
//		  <http://www.ietf.org/rfc/rfc4627.txt?number=4627>);
//		- Альтернативный – направлен на применение в проектах подразумевающих постоянный двусторонний
//		  обмен данными, по каналам связи Интернет, и требующих повышенную скорость обработки данных,
//		  минимизацию пересылаемых пакетов данных и однозначную идентификацию ссылочных типов во входящих данных.
//
//	Независимо от режима работы сериализатор, по требованию (см. Настройки), позволяет автоматически передавать 
//	не только уникальный идентификатор ссылки, но и ее представление, а парсер в свою очередь, 
//	анализируя входные данные, опускает представления ссылок, не включая их в результирующий набор данных.
//
//	При работе с проектами, в исходящих строковых данных которых не гарантируется отсутствие символов из диапазонов:
//		[0x007f, 0x009f], 0x00ad, [0x0600, 0x0604], 0x070f, [0x17b4, 0x17b5], 
//		[0x200c, 0x200f], [0x2028, 0x202f] [0x2060, 0x206f], 0xfeff, [0xfff0, 0xffff], 
//	рекомендуется не отключать настройку (см. Настройки) полного маскирования символов 
//	(подробнее см. <https://github.com/douglascrockford/JSON-js/blob/master/json2.js> и <http://sadesign.ru/tools/unicode>).
//
//	Независимо от режима работы сериализатор, по требованию (см. Настройки), может маскировать кириллические символы 
//	современных алфавитов славянских языков "АБВГҐДЂЃЕЀЁЄЖЗЅИЍІЇЙЈКЛЉМНЊОПРСТЋЌУЎФХЦЧЏШЩЪЫЬЭЮЯ" (включая нижний регистр) 
//	(подробнее см. <http://ru.wikipedia.org/wiki/Кириллица> и <http://ru.wikipedia.org/wiki/Кириллица_в_Юникоде>).
//
//	Поддерживаются все среды исполнения с ограничением сериализуемых типов. Используется кроссплатформенный код.



// История изменения:
//	Версия 2.0.0.17:
//		- (Новое) Маскирование кириллических символов современных алфавитов славянских языков (по требованию);
//		- (Новое) Поддержка сериализатором типов: ДвоичныеДанные, Картинка, ХранилищеЗначения;
//		- (Изменение) Рефакторинг переменных и процедур;
//		- (Исправление) Сериализация типа COMSafeArray;
//		- (Исправление) Удалены лишние ключевые слова "Экспорт".
//		- (Оптимизация) Уменьшение проверок связанных с режимом и параметрами парсинга и сериализцаии;
//		- (Оптимизация) Проверка необходимости анализа форматирования вынесена из процедуры анализа форматирования;
//		- (Оптимизация) Изменен алгоритм автоматического приведение объекта к структуре или соответствию в зависимости от имен свойств;
//		- (Оптимизация) Отказ от явного приведения типов в пользу неявного в операторах условий;
//		- (Оптимизация) Отказ от оператора "Попытка Исключение" при преобразовании строки к уникальному идентификатору;
//		- (Оптимизация) Изменен порядок проверки типов при парсинге.
//	Версия 2.0.0.15
//		- Релиз.



// Методы:
//	ПрочитатьJSON – парсер;
//	ЗаписатьJSON – сериализатор.

// Настройки и параметры:
//
//	Параметры функций:
//		Стандарт – определяет режим работы парсера и сериализатора:
//			- Истина		– стандартный режим (значение по умолчанию);
//			- Ложь			– альтернативный режим;
//			- Неопределено	– автоматическое определение режима входящих данных
//							  (только парсер, не рекомендуется – влияет на производительность).
//
//		ПредставленияСсылок – позволяет автоматически передавать не только значение ссылки, но и ее представление:
//			- Истина		- ссылка парсится и сериализуется как объект с двумя свойствами "Ссылка" и "Представление";
//			- Ложь			- ссылка парсится и сериализуется как уникальный идентификатор ссылки (значение по умолчанию);
//			- Неопределено	– автоматическое определение формата ссылок во входящих данных
//							  (только парсер, не рекомендуется – влияет на производительность).
//
//	Настройки:
//		АвтоматическоеПриведениеОбъектаКСтруктуре – автоматическое приведение объекта к структуре, а не к соответствию.
//			Настройка изменяется в функции "АвтоматическоеПриведениеОбъектаКСтруктуре" (по умолчанию отключена).
//			Автоматическое приведение к структуре выполняется только для объектов имена свойств, которых могут быть 
//			использованы как ключи структуры, все остальные объекты преобразуются в соответствие.
//
//		ПолноеМаскированиеСимволов – маскирование символов некорректно обрабатываемых JavaScript-ом.
//			Настройка изменяется в функции "НастройкаПолноеМаскированиеСимволов" (по умолчанию включена).
//			Не рекомендуется к использованию, так как влияет на производительность, но гарантирует безопасную передачу данных.
//			Маскирование специальных символов из диапазона [0x0000, 0x001f] выполняется в не зависимости от настройки.
//
//		МаскированиеКириллицы – маскирование кириллических символов современных алфавитов славянских языков.
//			Настройка изменяется в функции "НастройкаМаскированиеКириллицы" (по умолчанию отключена).
//			Не рекомендуется к использованию, так как влияет на производительность.
//			Маскирование специальных символов из диапазона [0x0000, 0x001f] выполняется в не зависимости от настройки.
//
//		НеявноеПриведениеПримитивныхЗначенийКлюча – неявное приведение примитивных значений ключей соответствий к строке.
//			Настройка изменяется в функции "НеявноеПриведениеПримитивныхЗначенийКлюча" (по умолчанию отключена).


// Альтернативный режим:
//		- Не поддерживается форматирование, как во входящих, так и в исходящих данных;
//		- Сериализация ссылочных типов в строковое служебное представление.


// Приятности:
//	Парсер:
//		- Устойчивость к некорректным данным и не подверженность injection атакам;
//		- Продвинутый синтаксический анализатор (указывает место и тип ошибки в данных);
//		- Поддержка форматирования во входящих данных (только стандартный режим);
//		- Безопасный разбор форматирования - незамаскированные символы форматирования в строковых значениях не будут утеряны;
//		- Поддержка строк в одинарных и в двойных кавычках;
//		- Автоматическое приведение объекта к структуре или соответствию в зависимости от имен свойств¹;
//		- Автоматическое преобразование к типу Дата строки вида "9999-99-99T99:99:99Z";
//		- Автоматическое преобразование к типу УникальныйИдентификатор строки вида "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
//		- Автоматического определение режима (стандартного или альтернативного) входящих данных;
//		- Автоматического определение необходимости отсечения представления ссылок;
//		- Однозначная идентификация ссылок (только альтернативный режим).
//	Сериализатор:
//		- Поддержка форматирования исходящих данных (только стандартный режим);
//		- Широкий состав сериализуемых типов данных, в том числе ссылок;
//		- Автоматическое приведение значений ключей соответствий к строковому представлению в формате 1С²;
//		- Автоматическое преобразование неподдерживаемых типов к строке;
//		- Маскирование кириллических символов современных алфавитов славянских языков;
//		- Нечувствительность к локализации³.
// ----
//  ¹ Если все имена свойства входящего объекта могут быть использованы как ключи структуры, 
//    то такой объект будет автоматически приведен к структуре, а не к соответствию. Управляется настройкой.
//  ² Управляется настройкой.
//  ³ При сериализации некоторых типов, исходящие объекты которых имеют обязательные свойства, 
//    такие представления и имена таких свойств всегда имеют русскую локализацию.


// Неприятности:
//		- Нестандартно форматированный код (Alt+Shift+F в помощь) на гране читаемости; 
//		- Сериализатор ориентирован, на средние-крупные пакеты данных.

// Сериализуемые типы:
//	Сервер, толстый клиент, тонкий клиент, веб-клиент:
//		- Неопределено;
//		- Null;
//		- Примитивные типы (все);
//		- Универсальные коллекции значений (клиентские);
//		- УникальныйИдентификатор;
//		- ДвоичныеДанные;
//		- Картинка.
//	Сервер, толстый клиент:
//		- Универсальные коллекции значений (серверные);
//		- ЛюбаяСсылка;
//		- Запрос;
//		- РезультатЗапроса;
//		- ВыборкаИзРезультатаЗапроса;
//		- ПостроительЗапроса;
//		- ПостроительОтчета;
//		- ХранилищеЗначения.
//	Сервер:
//		- ДанныеФормыКоллекция;
//		- ДанныеФормыСтруктураСКоллекцией;
//		- ДанныеФормыДерево.

// Порядок сериализации типов:
//		- Неопределено - сериализуется как Null;
//		- Null - согласно стандарту;
//		- Примитивные типы - согласно стандарту;
//		- Массивы и COMSafeArray - массив, согласно стандарту:
//				[ Значение, ... ]
//
//		- Структуры и соответствия – объект, согласно стандарту;
//				{ Ключ:Значение, ... }
//
//		- СписокЗначений - массив объектов с тремя свойствами "Значение", "Представление" и "Пометка";
//				[ { "Значение":Значение, "Представление":Представление, "Пометка":Пометка }, ... ]
//
//		- КлючИЗначение - объект с двумя свойствами "Ключ" и "Значени";
//				{ "Ключ":Ключ, "Значение":Значение }
//
//		- ТаблицаЗначений - массив объектов: 
//				[ { Колонка:Значение, ... }, ... ]
//
//		- ДеревоЗначений - массив объектов с обязательным свойством "Строки":
//				[ { Колонка:Значение, ... , "Строки":[ { Колонка:Значение, ... , "Строки":[ ... ] } , ... ] }, ... ]
//
//		- УникальныйИдентификатор - приведение к строке вида "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
//
//		- ЛюбаяСсылка:
//			- Стандартный режим - получение уникального идентификатора ссылки (в том числе и для перечислений) и его сериализация;
//			- Альтернативный режим - приведение к строке служебного вида "¦ref¦ ... ¦";
//
//		  При сериализации ссылок в режиме автоматически передачи не только сериализованного значения ссылки, 
//		  но и ее представления. Каждая ссылка передается как объект с двумя свойствами "Ссылка" и "Представление";
//				{ "Ссылка":Ссылка, "Представление":Представление }
//
//		- Запрос - автоматически выполняется и сериализуется как таблица значений;
//		- РезультатЗапроса - сериализуется как таблица значений;
//		- ВыборкаИзРезультатаЗапроса - сериализуется как структура значений текущей запись результата запроса;
//		- ПостроительЗапроса - автоматически выполняется и сериализуется как таблица значений;
//		- ПостроительОтчета - автоматически выполняется и сериализуется как таблица значений;
//		- ДанныеФормыКоллекция - сериализуется как таблица значений;
//		- ДанныеФормыСтруктураСКоллекцией - сериализуется как таблица значений;
//		- ДанныеФормыДерево - сериализуется как дерево значений;
//		- ДвоичныеДанные - кодируется по алгоритму base64¹ и сериализуется как строка;
//		- Картинка - автоматически преобразуется и сериализуется как двоичные данные;
//		- ХранилищеЗначения - автоматически извлекается сохраненное значение и сериализуется в зависимости от типа извлеченного значения.
// ----
//  ¹ Следуя рекомендациям стандарта, сериализатор при кодировании по алгоритму base64, не добавляет переводы строк 
//    в результирующие данные (подробнее см. <http://tools.ietf.org/html/rfc4648#section-3.1>).

// Производительность:
//	Производительность парсера исключительно зависит от набора входящих данных, а также от наличия форматирования.
//	Наихудшим вариантом является форматированный массив чисел, наилучшим - неформатированный массив строк.
//
//	Intel Core 2 Duo T5870 @ 2GHz - форматированный массив со всеми приблизительно равномерно встречающимися типами данных:
//		Парсер:			35 Кбайт/с.
//		Сериализатор:	165 Кбайт/с.

// Примечание:
//	Мало комментариев - без комментариев.

// Всем удачного программирования :)


// ─────────────────────────────────────────────────────────────────────────────
//	JSON

// JSON парсер.
//
// Параметры:
//	Значение - Строка. Строка данных в формате JSON для парсинга;
//
//  Стандарт - Неопределено, Булево. Режим работы:
//		- Истина - стандартный режим (значение по умолчанию);
//		- Ложь - альтернативный режим;
//		- Неопределено - автоопределение режима;
//
//  ПредставленияСсылок - Неопределено, Булево. Режим передачи ссылочных типов, с их представлением или без:
//		- Истина - ссылки передаются вместе со своим представлением, как объекты с двумя свойствами содержащими саму ссылку и ее представление;
//		- Ложь - ссылки передаются без представления (значение по умолчанию).
//		- Неопределено - автоопределение режима.
// 
// Возвращаемое значение:
//  Набор данных согласно содержимому входящих данных. 
//
Функция ПрочитатьJSON_Обработка(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь) Экспорт 
	
	Возврат jsonПрочитатьИнициализация(Значение, Стандарт, ПредставленияСсылок);
	
КонецФункции // ПрочитатьJSON()

// JSON сериализатор.
//
// Параметры:
//	Значение. Набор данных сериализуемых в формат JSON;
//
//  Стандарт - Булево. Режим работы:
//		- Истина - стандартный режим (значение по умолчанию);
//		- Ложь - альтернативный режим;
//
//  ПредставленияСсылок - Булево. Режим передачи ссылочных типов, с их представлением или без:
//		- Истина - ссылки передаются вместе со своим представлением, как объекты с двумя свойствами содержащими саму ссылку и ее представление;
//		- Ложь - ссылки передаются без представления (значение по умолчанию).
// 
// Возвращаемое значение:
//  Строка. Строка данных в формате JSON согласно содержимому входящих данных. 
//
Функция ЗаписатьJSON_Обработка(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь) Экспорт 
	
	Возврат jsonЗаписатьИнициализация(Значение, Стандарт, ПредставленияСсылок);
	
КонецФункции // ЗаписатьJSON()


// ─────────────────────────────────────────────────────────────────────────────
//  НАСТРОЙКИ

// Функция управляющая настройкой "АвтоматическоеПриведениеОбъектаКСтруктуре".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется автоматическое приведение объекта к структуре; 
//		- Ложь - автоматическое приведение объекта к структуре не выполняется, все объекты преобразуются в соответствие. 
//
// Примечание:
//  Автоматическое приведение к структуре выполняется только для объектов имена свойств которых могут быть 
//  использованы как ключи структуры, все остальные объекты преобразуются в соответствие.
//
Функция НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре()
	
	Возврат Ложь;	// Измените для использования автоматического приведения объекта к структуре.
	
КонецФункции // НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре()

// Функция управляющая настройкой "ПолноеМаскированиеСимволов".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется полное маскирование символов некорректно обрабатываемых JavaScript-ом; 
//		- Ложь - маскирование выполняется только согласно стандарту и дополнительно маскируются специальные символы. 
//
// Примечание:
//	Маскирование специальных символов из диапазона [0x0000, 0x001f] выполняется в не зависимости от настройки.
//
Функция НастройкаПолноеМаскированиеСимволов()
	
	Возврат Истина;	// Измените для неполного маскирования символов.
	
КонецФункции // НастройкаПолноеМаскированиеСимволов()

// Функция управляющая настройкой "МаскированиеКириллицы".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется маскирование кириллических символов; 
//		- Ложь - маскирование выполняется только согласно стандарту и дополнительно маскируются специальные символы. 
//
// Примечание:
//	Маскирование специальных символов из диапазона [0x0000, 0x001f] выполняется в не зависимости от настройки.
//
Функция НастройкаМаскированиеКириллицы()
	
	Возврат Ложь;	// Измените для маскирования кириллических символов.
	
КонецФункции // НастройкаМаскированиеКириллицы()

// Функция управляющая настройкой "НеявноеПриведениеПримитивныхЗначенийКлюча".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется неявное приведение примитивных типов значений ключей соответствий к их строковому представлению в формате 1С; 
//		- Ложь - неявное приведение примитивных типов значений ключей соответствий к строковому представлению не выполняется. 
//
// Примечание:
//	Неявно приводимые типы: Null, Булево, Число, Дата, Строка, УникальныйИдентификатор.
//
Функция НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча()
	
	Возврат Ложь;	// Измените для использования неявного приведения примитивных значений ключей соответствий к строке.
	
КонецФункции // НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча()


// ─────────────────────────────────────────────────────────────────────────────
//  ПАРСЕР

Функция jsonПрочитатьИнициализация(Значение, Знач Стандарт, Знач ПредставленияСсылок)
	
	// Проверка параметров.
	Если (Не Стандарт = Истина) И (Не Стандарт = Ложь) И (Не Стандарт = Неопределено) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("Стандарт"); КонецЕсли; 
	Если (Не ПредставленияСсылок = Истина) И (Не ПредставленияСсылок = Ложь) И (Не ПредставленияСсылок = Неопределено) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("ПредставленияСсылок"); КонецЕсли; 
	
	// Использование более общего случая параметров.
	Альтернативный = (Стандарт = Неопределено) Или (Не Стандарт); Стандарт = (Стандарт = Неопределено) Или Стандарт; ПредставленияСсылок = (ПредставленияСсылок = Неопределено) Или ПредставленияСсылок;
	
	// Схема подстановок шестнадцатиричной системы.
	СхемаПодстановок = Новый Соответствие; ШестнадцатиричнаяСистема = "0123456789abcdef"; ДесятичноеЧисло = 0;
	Для ВторойРазряд = 1 По 16 Цикл Для ПервыйРазряд = 1 По 16 Цикл СхемаПодстановок.Вставить(Сред(ШестнадцатиричнаяСистема, ВторойРазряд, 1) + Сред(ШестнадцатиричнаяСистема, ПервыйРазряд, 1), ДесятичноеЧисло); ДесятичноеЧисло = ДесятичноеЧисло + 1; КонецЦикла; КонецЦикла;
	
	// Вспомогательные данные.
	ВспомогательныеДанные = Новый Структура("ТипСтроки,СхемаПодстановок,АвтоматическиПриводитьКСтруктуре",
	Тип("Строка"),
	СхемаПодстановок,
	(НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре() = Истина));
	
	// Стартовые значения.
	Индекс = 1; Длина = СтрДлина(Значение);
	
	// Форматирование (первый шаг парсера).
	Если Стандарт Тогда СимволыФорматирования = " " + Символы.ВК + Символы.ПС + Символы.Таб; jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли;
	Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеПустойПакетДанных(); КонецЕсли; 
	
	// Парсер.
	Возврат jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Истина);
	
КонецФункции // jsonПрочитатьИнициализация()

Функция jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, ПервыйУровень)
	
	Символ = Сред(Значение, Индекс, 1);
	Если (Символ = """") Или (Символ = "'") Тогда        																	// " , '
		
		// Строка.
		Подстрока = Сред(Значение, Индекс + 1); Начало = Индекс; Пока Истина Цикл
			Позиция = Найти(Подстрока, Символ);
			
			Если (Позиция > 0) Тогда
				Индекс = Индекс + Позиция; Откат = Позиция - 1; Маскировка = Ложь; Пока (Сред(Подстрока, Откат, 1) = "\") И Откат Цикл Маскировка = Не Маскировка; Откат = Откат - 1; КонецЦикла;
				Если Маскировка Тогда Подстрока = Сред(Подстрока, Позиция + 1); Иначе Прервать; КонецЕсли;
			Иначе
				ВызватьИсключение ИсключениеНеожиданноеОкончаниеПакетаДанных();
			КонецЕсли;
			
		КонецЦикла;
		
		// Строка.
		Результат = jsonПрочитатьСтроку(Сред(Значение, Начало + 1, Индекс - Начало - 1), Стандарт, Начало, ВспомогательныеДанные.СхемаПодстановок, (Символ = "'"));
		
		Если jsonПрочитатьОпределитьДату(Результат) Тогда
			// Дата.
			Результат = jsonПрочитатьДату(Результат, Начало);
		ИначеЕсли jsonПрочитатьОпределитьИдентификатор(Результат) Тогда
			// Идентификатор.
			Результат = jsonПрочитатьИдентификатор(Результат, Начало);
		Иначе
			Если Альтернативный И jsonПрочитатьОпределитьВнутреннийТип(Результат) Тогда
				// Внутренний тип.
				Результат = jsonПрочитатьВнутреннийТип(Результат, Начало);
			КонецЕсли;
		КонецЕсли;
		
		// Корректировка индекса.
		Индекс = Индекс + 1;
		
	ИначеЕсли (Символ = "[") Тогда																							// [
		
		// Массив.
		Результат = Новый Массив;
		
		Индекс = Индекс + 1; Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеМассива(Длина); КонецЕсли;
		Символ = Сред(Значение, Индекс, 1); Если (Символ = "]") Тогда														// ] 
			
			// Пустой массив.
			Индекс = Индекс + 1;
			
		Иначе
			
			Пока (Индекс <= Длина) Цикл
				
				// Значение.
				Результат.Добавить(jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь));
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = "]") Тогда																					// ]
					// Окончание массива.
					Индекс = Индекс + 1; Прервать;
				Иначе
					// Продолжение массива.
					Если (Символ = ",") Тогда																				// ,
						Индекс = Индекс + 1; Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если (Индекс >= Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеМассива(Длина); КонецЕсли;
					Иначе
						ВызватьИсключение ИсключениеНедопустимыйСимвол(Индекс, ",");
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	ИначеЕсли (Символ = "{") Тогда																							// {
		
		// Объект.
		Индекс = Индекс + 1; Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеМассива(Длина); КонецЕсли;
		Символ = Сред(Значение, Индекс, 1); Если (Символ = "}") Тогда														// } 
			
			// Пустой объект.
			Индекс = Индекс + 1;
			
			// Структура или соответствие.
			Если ВспомогательныеДанные.АвтоматическиПриводитьКСтруктуре Тогда Результат = Новый Структура; Иначе Результат = Новый Соответствие; КонецЕсли; 
			
		Иначе
			
			Результат = Новый Соответствие;
			
			ТипСтроки = ВспомогательныеДанные.ТипСтроки; Пока (Индекс <= Длина) Цикл
				
				// Ключ.
				Начало = Индекс; КлючЭлемента = jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь); Если (Не ТипЗнч(КлючЭлемента) = ТипСтроки) Тогда ВызватьИсключение ИсключениеНедопустимыйТипКлюча(Начало, КлючЭлемента); КонецЕсли;
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = ":") Тогда																					// :
					Индекс = Индекс + 1; Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если (Индекс >= Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеОбъетка(Длина); КонецЕсли;
				Иначе
					ВызватьИсключение ИсключениеНедопустимыйСимвол(Индекс, ":");
				КонецЕсли;
				
				// Значение.
				ЗначениеЭлемента = jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь);
				
				// Коллекция.
				Результат.Вставить(КлючЭлемента, ЗначениеЭлемента);
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = "}") Тогда																					// }
					// Окончание объекта.
					Индекс = Индекс + 1; Прервать;
				Иначе
					// Продолжение объекта.
					Если (Символ = ",") Тогда																				// ,
						Индекс = Индекс + 1; Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если (Индекс >= Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеОбъетка(Длина); КонецЕсли;
					Иначе
						ВызватьИсключение ИсключениеНедопустимыйСимвол(Индекс, ",");
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;
			
			// Структура или соответствие.
			Если ВспомогательныеДанные.АвтоматическиПриводитьКСтруктуре Тогда
				
				РезультатСтруктура = Новый Структура; 
				Для Каждого Элемент Из Результат Цикл Попытка РезультатСтруктура.Вставить(Элемент.Ключ, Элемент.Значение); Исключение РезультатСтруктура = Результат; АвтоматическоеПриведениеНеВыполнено = Истина; Прервать; КонецПопытки; КонецЦикла;
				Результат = РезультатСтруктура;
				
				// Ссылка.
				Если ПредставленияСсылок Тогда Результат = jsonПрочитатьСсылку(Результат, (АвтоматическоеПриведениеНеВыполнено = Истина)); КонецЕсли;
				
			Иначе
				
				// Ссылка.
				Если ПредставленияСсылок Тогда Результат = jsonПрочитатьСсылку(Результат, Истина); КонецЕсли;
				
			КонецЕсли; 
			
		КонецЕсли;
		
	Иначе
		
		// Остальные примитивные типы.
		Если (Символ = "n") Тогда
			
			// Null.
			Если (Сред(Значение, Индекс, 4) = "null") Тогда Индекс = Индекс + 4; Результат = Null; Иначе ВызватьИсключение ИсключениеНекорректныйТипNull(Индекс); КонецЕсли;
			
		ИначеЕсли (Символ = "t") Тогда
			
			// Истина.
			Если (Сред(Значение, Индекс, 4) = "true") Тогда Индекс = Индекс + 4; Результат = Истина; Иначе ВызватьИсключение ИсключениеНекорректныйТипБулево(Индекс); КонецЕсли;
			
		ИначеЕсли (Символ = "f") Тогда
			
			// Ложь.
			Если (Сред(Значение, Индекс, 5) = "false") Тогда Индекс = Индекс + 5; Результат = Ложь; Иначе ВызватьИсключение ИсключениеНекорректныйТипБулево(Индекс); КонецЕсли;
			
		ИначеЕсли (Символ = "u") Тогда
			
			// Неопределено.
			Если (Сред(Значение, Индекс, 9) = "undefined") Тогда Индекс = Индекс + 9; Результат = Неопределено; Иначе ВызватьИсключение ИсключениеНекорректныйТипНеопределено(Индекс); КонецЕсли;
			
		Иначе
			
			// Число.
			Начало = Индекс; Пока Найти("-+0123456789.", Символ) И (Индекс <= Длина) Цикл Индекс = Индекс + 1; Символ = Сред(Значение, Индекс, 1); КонецЦикла;
			
			// Преобразование числа.
			Попытка
				Результат = Число(Сред(Значение, Начало, Индекс - Начало));
			Исключение
				ВызватьИсключение ИсключениеНекорректныйФорматЧисла(Начало, Сред(Значение, Начало, Индекс - Начало)); 
			КонецПопытки;
			
			// Экспоненциальная часть.
			Если (Символ = "E") Или (Символ = "e") Тогда
				
				// Степень.
				Индекс = Индекс + 1; Позиция = Индекс; Символ = Сред(Значение, Индекс, 1); Пока Найти("-+0123456789", Символ) И (Индекс <= Длина) Цикл Индекс = Индекс + 1; Символ = Сред(Значение, Индекс, 1); КонецЦикла;
				
				// Преобразование степени.
				Попытка
					Степень = Число(Сред(Значение, Позиция, Индекс - Позиция));
				Исключение
					ВызватьИсключение ИсключениеНекорректныйФорматЧисла(Начало, Сред(Значение, Начало, Индекс - Начало)); 
				КонецПопытки;
				
				// Возвидение числа в степень.
				Результат = Результат * Pow(10, Степень);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Форматирование.
	Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если ПервыйУровень Тогда Если (Индекс <= Длина) Тогда ВызватьИсключение ИсключениеНекорректныйПакетДанных(Индекс); КонецЕсли; Иначе Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеПакетаДанных(); КонецЕсли; КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // jsonПрочитать()

Функция jsonПрочитатьОпределитьДату(Значение)
	
	// Проверка.
	Если (СтрДлина(Значение) = 20) Тогда
		Если (Сред(Значение, 05, 1) = "-") И				// -
			(Сред(Значение, 08, 1) = "-") И				// -
			(Сред(Значение, 11, 1) = "T") И				// T
			(Сред(Значение, 14, 1) = ":") И				// :
			(Сред(Значение, 17, 1) = ":") И				// :
			(Сред(Значение, 20, 1) = "Z") Тогда			// Z
			// Год. 
			Если Найти("0123456789", Сред(Значение, 01, 1)) И
				Найти("0123456789", Сред(Значение, 02, 1)) И
				Найти("0123456789", Сред(Значение, 03, 1)) И
				Найти("0123456789", Сред(Значение, 04, 1)) И
				// Месяц.
				Найти("0123456789", Сред(Значение, 06, 1)) И
				Найти("0123456789", Сред(Значение, 07, 1)) И
				// День.
				Найти("0123456789", Сред(Значение, 09, 1)) И
				Найти("0123456789", Сред(Значение, 10, 1)) И
				// Час.
				Найти("0123456789", Сред(Значение, 12, 1)) И
				Найти("0123456789", Сред(Значение, 13, 1)) И
				// Минута.
				Найти("0123456789", Сред(Значение, 15, 1)) И
				Найти("0123456789", Сред(Значение, 16, 1)) И
				// Секунда.
				Найти("0123456789", Сред(Значение, 18, 1)) И
				Найти("0123456789", Сред(Значение, 19, 1)) Тогда
				Возврат Истина; 
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции // jsonПрочитатьОпределитьДату()

Функция jsonПрочитатьОпределитьИдентификатор(Значение)
	
	// Проверка.
	Если (СтрДлина(Значение) = 36) Тогда
		Если (Сред(Значение, 09, 1) = "-") И					// -
			(Сред(Значение, 14, 1) = "-") И					// -
			(Сред(Значение, 19, 1) = "-") И					// -
			(Сред(Значение, 24, 1) = "-") Тогда				// -
			// Первая часть. 
			Для Индекс = 01 По 08 Цикл Если Не Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1)) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Вторая часть. 
			Для Индекс = 10 По 13 Цикл Если Не Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1)) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Третья часть. 
			Для Индекс = 15 По 18 Цикл Если Не Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1)) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Четвертая часть. 
			Для Индекс = 20 По 23 Цикл Если Не Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1)) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Пятая часть. 
			Для Индекс = 25 По 36 Цикл Если Не Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1)) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции // jsonПрочитатьОпределитьИдентификатор()

Функция jsonПрочитатьОпределитьВнутреннийТип(Значение)
	
	// Поиск.
	Возврат (Лев(Значение, 1) = "¦") И (Сред(Значение, 5, 1) = "¦") И (Прав(Значение, 1) = "¦"); // ¦xxx¦ ... ¦
	
КонецФункции // jsonПрочитатьОпределитьВнутреннийТип()

Функция jsonПрочитатьСтроку(Значение, Стандарт, Индекс, СхемаПодстановок, ОдинарнаяКавычка)
	
	// Последоавтельность перемаскировки.
	ПоследоавтельностьПеремаскировки = "\" + Символ(65535);
	
	// Демаскирование служебных символов.
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение, 
	"\\",			ПоследоавтельностьПеремаскировки),		// Перемаскирование последовательности.
	"\/",			"/"),           // x2f
	"\b",			Символ(008)),	// x08
	"\t",			Символы.Таб),   // x09
	"\n",			Символы.ПС),    // x0a
	"\f",			Символы.ПФ),    // x0c
	"\r",			Символы.ВК),    // x0d
	"\""",			"""");          // x22
	
	// Демаскирование Юникод символов.
	Позиция = Найти(Результат, "\u"); Пока Позиция Цикл
		СтаршийБайт = СхемаПодстановок[НРег(Сред(Результат, Позиция + 2, 2))]; МладшийБайт = СхемаПодстановок[НРег(Сред(Результат, Позиция + 4, 2))]; Если (СтаршийБайт = Неопределено) Или (МладшийБайт = Неопределено) Тогда ВызватьИсключение ИсключениеНекорректныйФорматСтроки(Индекс); КонецЕсли;
		Результат = СтрЗаменить(Результат, Сред(Результат, Позиция, 6), Символ(256 * СтаршийБайт + МладшийБайт)); Позиция = Найти(Результат, "\u");
	КонецЦикла;
	
	// Одинарная кавычка.
	Если ОдинарнаяКавычка Тогда Результат = СтрЗаменить(Результат, "\'", "'"); КонецЕсли;
	
	// Демаскирование перемаскированой последовательности.
	Возврат СтрЗаменить(Результат, ПоследоавтельностьПеремаскировки, "\");				
	
КонецФункции // jsonПрочитатьСтроку()

Функция jsonПрочитатьДату(Значение, Индекс)
	
	// Поиск.
	Попытка
		Возврат Дата(Лев(Значение, 4) + Сред(Значение, 06, 2) + Сред(Значение, 09, 2) + 
		Сред(Значение, 12, 2) + Сред(Значение, 15, 2) + Сред(Значение, 18, 2));
	Исключение
		ВызватьИсключение ИсключениеНекорректныйФорматДаты(Индекс, Значение);
	КонецПопытки;
	
КонецФункции // jsonПрочитатьДату()

Функция jsonПрочитатьСсылку(Значение, Соответствие)
	
	Перем Ссылка;
	
	// Ссылка.
	Если (Значение.Количество() = 2) Тогда 
		Если Соответствие Тогда
			Ссылка = Значение.Получить("Ссылка"); Если (Не Ссылка = Неопределено) И (Не Значение.Получить("Представление") = Неопределено) Тогда Возврат Ссылка; КонецЕсли;
		Иначе
			Если Значение.Свойство("Представление") И Значение.Свойство("Ссылка", Ссылка) Тогда Возврат Ссылка; КонецЕсли;
		КонецЕсли;
	КонецЕсли;	
	
	Возврат Значение;
	
КонецФункции // jsonПрочитатьСсылку()

Функция jsonПрочитатьИдентификатор(Значение, Индекс)
	
	// Поиск.
	Возврат Новый УникальныйИдентификатор(Значение);
	
КонецФункции // jsonПрочитатьИдентификатор()

Функция jsonПрочитатьВнутреннийТип(Значение, Индекс)
		
		// Поиск.
		Тип = Сред(Значение, 2, 3); Данные = Сред(Значение, 6, СтрДлина(Значение) - 6);
		
		Если (Тип = "ref") Тогда
			Попытка
				Возврат ЗначениеИзСтрокиВнутр("{""#""," + СтрЗаменить(СтрЗаменить(Данные, "×", ":"), "÷", ",") + "}");
			Исключение
				ВызватьИсключение ИсключениеНевозможноПреобразоватьЗначение(Индекс, Значение);
			КонецПопытки;
		КонецЕсли;
		
		ВызватьИсключение ИсключениеНеопознанныйТип(Индекс, Тип);
		
КонецФункции // jsonПрочитатьВнутреннийТип()

Процедура jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования)
	
	// Пропуск форматирования.
	Пока (Индекс <= Длина) И Найти(СимволыФорматирования, Сред(Значение, Индекс, 1)) Цикл Индекс = Индекс + 1; КонецЦикла;
	// Пробел его не видно, \r, \n, \t .
	
КонецПроцедуры // jsonПрочитатьПропуститьФорматирование()


// ─────────────────────────────────────────────────────────────────────────────
//  СЕРИАЛИЗАТОР

Функция jsonЗаписатьИнициализация(Значение, Знач Стандарт, Знач ПредставленияСсылок)
	
	// Проверка параметров.
	Если (Не Стандарт = Истина) И (Не Стандарт = Ложь) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("Стандарт"); КонецЕсли; 
	Если (Не ПредставленияСсылок = Истина) И (Не ПредставленияСсылок = Ложь) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("ПредставленияСсылок"); КонецЕсли; 
	
	ВспомогательныеДанные = Новый Структура("ПримитивныеТипы,Массивы,Структуры,Соответсвия,Построители,КлиентскиеТипы,ТипДопустимыхКлючей", 
	Новый ОписаниеТипов("Null,Булево,Число,Дата,УникальныйИдентификатор"),									// ПримитивныеТипы.
	Новый ОписаниеТипов("Массив,ФиксированныйМассив,ФиксированнаяКоллекция"),						// Массивы.
	Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура"),										// Структуры.
	Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура,Соответствие,ФиксированноеСоответствие"),	// Соответсвия.
	Новый ОписаниеТипов("ПостроительЗапроса,ПостроительОтчета"),										// Построители.
	Новый ОписаниеТипов("ДанныеФормыКоллекция,ДанныеФормыСтруктураСКоллекцией,ДанныеФормыДерево"),		// КлиентскиеТипы.
	Новый ОписаниеТипов("Строка"));																			// ТипДопустимыхКлючей.
	
	// Типы допустимых ключей.
	Если (НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча() = Истина) Тогда ВспомогательныеДанные.ТипДопустимыхКлючей = Новый ОписаниеТипов("Null,Булево,Число,Дата,Строка,УникальныйИдентификатор"); КонецЕсли;
	
	// форматирование.
	Если Стандарт Тогда Смещение = ""; Отступ = " "; Табуляция = "    "; ПереносСтроки = Символы.ПС; Иначе Смещение = ""; Отступ = ""; Табуляция = ""; ПереносСтроки = ""; КонецЕсли;
	
	// Сериализация.
	Возврат jsonЗаписать(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, (НастройкаПолноеМаскированиеСимволов() = Истина), (НастройкаМаскированиеКириллицы() = Истина));
	
КонецФункции // jsonЗаписатьИнициализация()

Функция jsonЗаписать(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы)
	
	// Определение типа.
	Тип = ТипЗнч(Значение);
	
	// Строка.
	Если (Тип = Тип("Строка")) Тогда Возврат jsonЗаписатьСтроку(Значение, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	
	// Неопределено и примитивные типы.
	Если ВспомогательныеДанные.ПримитивныеТипы.СодержитТип(Тип) Тогда 
		Если (Значение = Null) Или (Значение = Неопределено) Тогда
			Возврат "null";
		ИначеЕсли (Тип = Тип("Дата")) Тогда
			Возврат """" + XMLСтрока(Значение) + "Z""";
		ИначеЕсли (Тип = Тип("УникальныйИдентификатор")) Тогда
			Возврат """" + XMLСтрока(Значение) + """";
		Иначе
			Возврат XMLСтрока(Значение);
		КонецЕсли;
	КонецЕсли;
	
	// Структуры и строка дерева значений (структурой).
	Если ВспомогательныеДанные.Структуры.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
			
			// форматирование.
			СледующееСмещение = Смещение + Табуляция;
			
			Если (Колонки = Неопределено) Тогда
				
				// Структуры.
				Если МаскированиеКириллицы Тогда
					
					Первый = Истина; Для Каждого Элемент Из Значение Цикл
						Если Первый Тогда
							Результат = ПереносСтроки + СледующееСмещение + jsonЗаписатьСтроку(Элемент.Ключ, ПолноеМаскированиеСимволов, МаскированиеКириллицы) + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
						Иначе
							Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписатьСтроку(Элемент.Ключ, ПолноеМаскированиеСимволов, МаскированиеКириллицы) + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
						КонецЕсли;
					КонецЦикла;
					
				Иначе
					
					Первый = Истина; Для Каждого Элемент Из Значение Цикл
						Если Первый Тогда
							Результат = ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
						Иначе
							Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
						КонецЕсли;
					КонецЦикла;
					
				КонецЕсли;
				
			Иначе
				
				// Строка дерева значений (структурой).
				Если МаскированиеКириллицы Тогда
					
					Первый = Истина; Для Каждого Элемент Из Значение Цикл
						Если (Элемент.Ключ = "Строки") Тогда Продолжить; КонецЕсли;
						Если Первый Тогда
							Результат = ПереносСтроки + СледующееСмещение + jsonЗаписатьСтроку(Элемент.Ключ, ПолноеМаскированиеСимволов, МаскированиеКириллицы) + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
						Иначе
							Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписатьСтроку(Элемент.Ключ, ПолноеМаскированиеСимволов, МаскированиеКириллицы) + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
						КонецЕсли;
					КонецЦикла;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + """\u0421\u0442\u0440\u043e\u043a\u0438"":" + Отступ + jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """\u0421\u0442\u0440\u043e\u043a\u0438"":" + Отступ + jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					КонецЕсли;
					
				Иначе
					
					Первый = Истина; Для Каждого Элемент Из Значение Цикл
						Если (Элемент.Ключ = "Строки") Тогда Продолжить; КонецЕсли;
						Если Первый Тогда
							Результат = ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
						Иначе
							Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
						КонецЕсли;
					КонецЦикла;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + """Строки"":" + Отступ + jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """Строки"":" + Отступ + jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			Возврат "{" + Результат + ПереносСтроки + Смещение + "}";
			
		Иначе
			
			// Пустая структура.
			Возврат "{}";
			
		КонецЕсли;
	КонецЕсли;
	
	// Соответсвия.
	Если ВспомогательныеДанные.Соответсвия.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
			
			// форматирование.
			СледующееСмещение = Смещение + Табуляция;
			
			// Соответсвия.
			ТипДопустимыхКлючей = ВспомогательныеДанные.ТипДопустимыхКлючей;
			
			Если МаскированиеКириллицы Тогда
				
				Первый = Истина; Для Каждого Элемент Из Значение Цикл
					Ключ = Элемент.Ключ; Если ТипДопустимыхКлючей.СодержитТип(ТипЗнч(Ключ)) Тогда Ключ = jsonЗаписатьСтроку(Строка(Ключ), ПолноеМаскированиеСимволов, МаскированиеКириллицы); Иначе ВызватьИсключение ИсключениеНедопустимыйТипКлюча(Неопределено, Ключ); КонецЕсли;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					КонецЕсли;
				КонецЦикла;
				
			Иначе
				
				Первый = Истина; Для Каждого Элемент Из Значение Цикл
					Ключ = Элемент.Ключ; Тип = ТипЗнч(Ключ); Если (Тип = Тип("Строка")) Тогда Ключ = jsonЗаписатьСтроку(Ключ, ПолноеМаскированиеСимволов, МаскированиеКириллицы); ИначеЕсли ТипДопустимыхКлючей.СодержитТип(Тип) Тогда Ключ = """" + Ключ + """"; Иначе ВызватьИсключение ИсключениеНедопустимыйТипКлюча(Неопределено, Ключ); КонецЕсли;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					КонецЕсли;
				КонецЦикла;
				
			КонецЕсли;
			Возврат "{" + Результат + ПереносСтроки + Смещение + "}";
			
		Иначе
			
			// Пустое соответсвие.
			Возврат "{}";
			
		КонецЕсли;
	КонецЕсли;
	
	// Массивы.
	Если ВспомогательныеДанные.Массивы.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
			
			// форматирование.
			СледующееСмещение = Смещение + Табуляция;
			
			Первый = Истина; Для Каждого Элемент Из Значение Цикл
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Элемент, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Элемент, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
			
		Иначе
			
			// Пустой массив.
			Возврат "[]";
			
		КонецЕсли;
	КонецЕсли;
	
	// Список значений.
	Если (Тип = Тип("СписокЗначений")) Тогда
		Если Значение.Количество() Тогда
			
			// форматирование.
			СледующееСмещение = Смещение + Табуляция;
			
			Структура = Новый Структура("Значение,Представление,Пометка");
			Первый = Истина; Для Каждого Элемент Из Значение Цикл
				ЗаполнитьЗначенияСвойств(Структура, Элемент);
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
			
		Иначе
			
			// Пустой список значений.
			Возврат "[]";
			
		КонецЕсли;
	КонецЕсли;
	
	// Таблица значений.
	#Если ВебКлиент Или ТонкийКлиент Тогда
	#Иначе
		Если (Тип = Тип("ТаблицаЗначений")) Тогда
			Если Значение.Количество() Тогда
				
				// форматирование.
				СледующееСмещение = Смещение + Табуляция;
				
				Структура = Новый Структура; НаборКолонок = Значение.Колонки; Для Каждого Колонка Из НаборКолонок Цикл Структура.Вставить(Колонка.Имя); КонецЦикла;
				
				Первый = Истина; Для Каждого Элемент Из Значение Цикл
					ЗаполнитьЗначенияСвойств(Структура, Элемент);
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					КонецЕсли;
				КонецЦикла;
				Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
				
			Иначе
				
				// Пустая таблица значений.
				Возврат "[]";
				
			КонецЕсли;
		КонецЕсли;
		
		// Коллекция строк дерева значений.
		Если (Тип = Тип("КоллекцияСтрокДереваЗначений")) Тогда
			Если Значение.Количество() Тогда
				
				// форматирование.
				СледующееСмещение = Смещение + Табуляция;
				
				Структура = Колонки; Первый = Истина; Для Каждого Элемент Из Значение Цикл
					ЗаполнитьЗначенияСвойств(Структура, Элемент); Структура.Строки = Элемент.Строки;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					КонецЕсли;
				КонецЦикла;
				Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
				
			Иначе
				
				// Пустая коллекция строк.
				Возврат "[]";
				
			КонецЕсли;
		КонецЕсли;
		
		// Дерево значений.
		Если (Тип = Тип("ДеревоЗначений")) Тогда
			
			Структура = Новый Структура("Строки"); НаборКолонок = Значение.Колонки; Для Каждого Колонка Из НаборКолонок Цикл Структура.Вставить(Колонка.Имя); КонецЦикла;
			Возврат jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Структура, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
			
		КонецЕсли;
		
		// Запрос.
		Если (Тип = Тип("Запрос")) Тогда Попытка Возврат jsonЗаписать(Значение.Выполнить().Выгрузить(), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Исключение ВызватьИсключение ИсключениеНевозможноВыполнитьЗапрос(ИнформацияОбОшибке().Причина.Описание); КонецПопытки; КонецЕсли;
		
		// Результат запроса.
		Если (Тип = Тип("РезультатЗапроса")) Тогда Возврат jsonЗаписать(Значение.Выгрузить(), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
		
		// Выборка из результата запроса.
		Если (Тип = Тип("ВыборкаИзРезультатаЗапроса")) Тогда
			
			Структура = Новый Структура; НаборКолонок = Значение.Владелец().Колонки; Для Каждого Колонка Из НаборКолонок Цикл Структура.Вставить(Колонка.Имя); КонецЦикла;
			ЗаполнитьЗначенияСвойств(Структура, Значение);
			Возврат jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
			
		КонецЕсли;
		
		// Построители.
		Если ВспомогательныеДанные.Построители.СодержитТип(Тип) Тогда Попытка Значение.Выполнить(); Исключение ВызватьИсключение ИсключениеНевозможноВыполнитьЗапрос(ИнформацияОбОшибке().Причина.Описание); КонецПопытки; Возврат jsonЗаписать(Значение.Результат, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
		
		// Хранилище значения.
		Если (Тип = Тип("ХранилищеЗначения")) Тогда Возврат jsonЗаписать(Значение.Получить(), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	#КонецЕсли
	
	// Двоичные данные.
	Если (Тип = Тип("ДвоичныеДанные")) Тогда
		Возврат """" + СтрЗаменить(СтрЗаменить(СтрЗаменить(XMLСтрока(Значение), Символы.ВК, ""), Символы.ПС, ""), "/", "\/") + """";
	КонецЕсли;
	
	// Картинка.
	Если (Тип = Тип("Картинка")) Тогда
		Возврат """" + СтрЗаменить(СтрЗаменить(СтрЗаменить(XMLСтрока(Значение.ПолучитьДвоичныеДанные()), Символы.ВК, ""), Символы.ПС, ""), "/", "\/") + """";
	КонецЕсли;
	
	// Ключ и значение.
	Если (Тип = Тип("КлючИЗначение")) Тогда Возврат jsonЗаписать(Новый Структура("Ключ,Значение", Значение.Ключ, Значение.Значение), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	
	// Клиентские типы.
	Если ВспомогательныеДанные.КлиентскиеТипы.СодержитТип(Тип) Тогда
		Если (Тип = Тип("ДанныеФормыДерево")) Тогда
			Возврат jsonЗаписать(ДанныеФормыВЗначение(Значение, Тип("ДеревоЗначений")), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
		Иначе
			Возврат jsonЗаписать(Значение.Выгрузить(), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
		КонецЕсли;
	КонецЕсли;
	
	// COMSafeArray.
	Если (Тип = Тип("COMSafeArray")) Тогда Возврат jsonЗаписать(Значение.Выгрузить(), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	
	// Ссылки.
	Перечисление = Перечисления.ТипВсеСсылки().СодержитТип(Тип);
	Если Перечисление Или
		Справочники.ТипВсеСсылки().СодержитТип(Тип) Или
		Документы.ТипВсеСсылки().СодержитТип(Тип) Или
		ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Или
		ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Или
		ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Или
		Задачи.ТипВсеСсылки().СодержитТип(Тип) Или
		БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Или
		БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип) Или
		ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда 
		Возврат jsonЗаписатьСсылку(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Перечисление, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
	КонецЕсли;
	
	// Неподдерживаемые типы.
	Возврат jsonЗаписатьСтроку(Значение, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
	
КонецФункции // jsonЗаписать()

Функция jsonЗаписатьСтроку(Значение, ПолноеМаскированиеСимволов, МаскированиеКириллицы)
	
	// Маскирование служебных символов.
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение, 
	"\",			"\\"),			// x5c
	"/",			"\/"),			// x2f
	Символ(008),	"\b"),			// x08
	Символы.Таб,	"\t"), 			// x09
	Символы.ПС,		"\n"),			// x0a
	Символы.ПФ,		"\f"),			// x0c
	Символы.ВК,		"\r"),			// x0d
	"""",			"\""");			// x22
	
	// Маскирование специальных символов.
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
	Символ(00),		"\u0000"),
	Символ(01),		"\u0001"),
	Символ(02),		"\u0002"),
	Символ(03),		"\u0003"),
	Символ(04),		"\u0004"),
	Символ(05),		"\u0005"),
	Символ(06),		"\u0006"),
	Символ(07),		"\u0007"),
	Символ(11),		"\u000b"),
	Символ(14),		"\u000e"),
	Символ(15),		"\u000f"),
	Символ(16),		"\u0010"),
	Символ(17),		"\u0011"),
	Символ(18),		"\u0012"),
	Символ(19),		"\u0013"),
	Символ(20),		"\u0014"),
	Символ(21),		"\u0015"),
	Символ(22),		"\u0016"),
	Символ(23),		"\u0017"),
	Символ(24),		"\u0018"),
	Символ(25),		"\u0019"),
	Символ(26),		"\u001a"),
	Символ(27),		"\u001b"),
	Символ(28),		"\u001c"),
	Символ(29),		"\u001d"),
	Символ(30),		"\u001e"),
	Символ(31),		"\u001f");
	
	Если ПолноеМаскированиеСимволов Тогда
		
		// Маскирование сиволов обрабатываемых JavaScript-ом не правильно.
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
		Символ(127),	"\u007f"),
		Символ(128),	"\u0080"),
		Символ(129),	"\u0081"),
		Символ(130),	"\u0082"),
		Символ(131),	"\u0083"),
		Символ(132),	"\u0084"),
		Символ(133),	"\u0085"),
		Символ(134),	"\u0086"),
		Символ(135),	"\u0087"),
		Символ(136),	"\u0088"),
		Символ(137),	"\u0089"),
		Символ(138),	"\u008a"),
		Символ(139),	"\u008b"),
		Символ(140),	"\u008c"),
		Символ(141),	"\u008d"),
		Символ(142),	"\u008e"),
		Символ(143),	"\u008f"),
		Символ(144),	"\u0090"),
		Символ(145),	"\u0091"),
		Символ(146),	"\u0092"),
		Символ(147),	"\u0093"),
		Символ(148),	"\u0094"),
		Символ(149),	"\u0095"),
		Символ(150),	"\u0096"),
		Символ(151),	"\u0097"),
		Символ(152),	"\u0098"),
		Символ(153),	"\u0099"),
		Символ(154),	"\u009a"),
		Символ(155),	"\u009b"),
		Символ(156),	"\u009c"),
		Символ(157),	"\u009d"),
		Символ(158),	"\u009e"),
		Символ(159),	"\u009f"),
		Символ(173),	"\u00ad");
		
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
		Символ(1536),	"\u0600"),
		Символ(1537),	"\u0601"),
		Символ(1538),	"\u0602"),
		Символ(1539),	"\u0603"),
		Символ(1540),	"\u0604"),
		Символ(1807),	"\u070f"),
		Символ(6068),	"\u17b4"),
		Символ(6069),	"\u17b5"),
		Символ(8204),	"\u200c"),
		Символ(8205),	"\u200d"),
		Символ(8206),	"\u200e"),
		Символ(8207),	"\u200f"),
		Символ(8232),	"\u2028"),
		Символ(8233),	"\u2029"),
		Символ(8234),	"\u202a"),
		Символ(8235),	"\u202b"),
		Символ(8236),	"\u202c"),
		Символ(8237),	"\u202d"),
		Символ(8238),	"\u202e"),
		Символ(8239),	"\u202f"),
		Символ(8288),	"\u2060"),
		Символ(8289),	"\u2061"),
		Символ(8290),	"\u2062"),
		Символ(8291),	"\u2063"),
		Символ(8292),	"\u2064"),
		Символ(8293),	"\u2065"),
		Символ(8294),	"\u2066"),
		Символ(8295),	"\u2067");
		
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
		Символ(8296),	"\u2068"),
		Символ(8297),	"\u2069"),
		Символ(8268),	"\u206a"),
		Символ(8299),	"\u206b"),
		Символ(8300),	"\u206c"),
		Символ(8301),	"\u206d"),
		Символ(8302),	"\u206e"),
		Символ(8303),	"\u206f"),
		Символ(65279),	"\ufeff"),
		Символ(65520),	"\ufff0"),
		Символ(65521),	"\ufff1"),
		Символ(65522),	"\ufff2"),
		Символ(65523),	"\ufff3"),
		Символ(65524),	"\ufff4"),
		Символ(65525),	"\ufff5"),
		Символ(65526),	"\ufff6"),
		Символ(65527),	"\ufff7"),
		Символ(65528),	"\ufff8"),
		Символ(65529),	"\ufff9"),
		Символ(65530),	"\ufffa"),
		Символ(65531),	"\ufffb"),
		Символ(65532),	"\ufffc"),
		Символ(65533),	"\ufffd"),
		Символ(65534),	"\ufffe"),
		Символ(65535),	"\uffff");
		
	КонецЕсли;
	
	Если МаскированиеКириллицы Тогда
		
		// Маскирование кириллических символов.
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
		"А",            "\u0410"),
		"Б",            "\u0411"),
		"В",            "\u0412"),
		"Г",            "\u0413"),
		"Д",            "\u0414"),
		"Е",            "\u0415"),
		"Ж",            "\u0416"),
		"З",            "\u0417"),
		"И",            "\u0418"),
		"Й",            "\u0419"),
		"К",            "\u041a"),
		"Л",            "\u041b"),
		"М",            "\u041c"),
		"Н",            "\u041d"),
		"О",            "\u041e"),
		"П",            "\u041f"),
		"Р",            "\u0420"),
		"С",            "\u0421"),
		"Т",            "\u0422"),
		"У",            "\u0423"),
		"Ф",            "\u0424"),
		"Х",            "\u0425"),
		"Ц",            "\u0426"),
		"Ч",            "\u0427"),
		"Ш",            "\u0428"),
		"Щ",            "\u0429"),
		"Ъ",            "\u042a"),
		"Ы",            "\u042b"),
		"Ь",            "\u042c"),
		"Э",            "\u042d"),
		"Ю",            "\u042e"),
		"Я",            "\u042f");
		
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
		"а",            "\u0430"),
		"б",            "\u0431"),
		"в",            "\u0432"),
		"г",            "\u0433"),
		"д",            "\u0434"),
		"е",            "\u0435"),
		"ж",            "\u0436"),
		"з",            "\u0437"),
		"и",            "\u0438"),
		"й",            "\u0439"),
		"к",            "\u043a"),
		"л",            "\u043b"),
		"м",            "\u043c"),
		"н",            "\u043d"),
		"о",            "\u043e"),
		"п",            "\u043f"),
		"р",            "\u0440"),
		"с",            "\u0441"),
		"т",            "\u0442"),
		"у",            "\u0443"),
		"ф",            "\u0444"),
		"х",            "\u0445"),
		"ц",            "\u0446"),
		"ч",            "\u0447"),
		"ш",            "\u0448"),
		"щ",            "\u0449"),
		"ъ",            "\u044a"),
		"ы",            "\u044b"),
		"ь",            "\u044c"),
		"э",            "\u044d"),
		"ю",            "\u044e"),
		"я",            "\u044f");
		
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
		"’",            "\u2019"),
		"Ґ",            "\u0490"),
		"Ђ",            "\u0402"),
		"Ѓ",            "\u0403"),
		"Ѐ",            "\u0400"),
		"Ё",            "\u0401"),
		"Є",            "\u0404"),
		"Ѕ",            "\u0405"),
		"Ѝ",            "\u040d"),
		"І",            "\u0406"),
		"Ї",            "\u0407"),
		"Ј",            "\u0408"),
		"Љ",            "\u0409"),
		"Њ",            "\u040a"),
		"Ћ",            "\u040b"),
		"Ќ",            "\u040c"),
		"Ў",            "\u040e"),
		"Џ",            "\u040f"),
		"ґ",            "\u0491"),
		"ђ",            "\u0452"),
		"ѓ",            "\u0453"),
		"ѐ",            "\u0450"),
		"ё",            "\u0451"),
		"є",            "\u0454"),
		"ѕ",            "\u0455"),
		"ѝ",            "\u045d"),
		"і",            "\u0456"),
		"ї",            "\u0457"),
		"ј",            "\u0458"),
		"љ",            "\u0459"),
		"њ",            "\u045a"),
		"ћ",            "\u045b"),
		"ќ",            "\u045c"),
		"ў",            "\u045e"),
		"џ",            "\u045f");						
		
	КонецЕсли;
	
	// Кавычки.
	Возврат """" + Результат + """";
	
КонецФункции // jsonЗаписатьСтроку()

Функция jsonЗаписатьСсылку(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Перечисление, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы)
	#Если ВебКлиент Или ТонкийКлиент Тогда
	#Иначе
		
		// Идентификатор.
		Если Стандарт Тогда 
			Если Перечисление Тогда Идентификатор = Лев(Прав(ЗначениеВСтрокуВнутр(Значение), 33), 32); Идентификатор = Прав(Идентификатор, 8) + "-" + Сред(Идентификатор, 21, 4) + "-" + Сред(Идентификатор, 17, 4) + "-" + Лев(Идентификатор, 4) + "-" + Сред(Идентификатор, 5, 12); Иначе Идентификатор = XMLСтрока(Значение); КонецЕсли;
		Иначе 
			Идентификатор = ЗначениеВСтрокуВнутр(Значение); Идентификатор = "¦ref¦" + СтрЗаменить(СтрЗаменить(Сред(Идентификатор, 6, СтрДлина(Идентификатор) - 6), ":", "×"), ",", "÷") + "¦";
		КонецЕсли;
		
		МетаданныеЗначения =  Значение.Метаданные();
		
		// Включая представление ссылки.
		Если ПредставленияСсылок Тогда Возврат jsonЗаписать(Новый Структура("Ссылка,Представление,Имя,Синоним", Идентификатор, Строка(Значение),МетаданныеЗначения.Имя,МетаданныеЗначения.Синоним), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
		
		// Ссылка.
		Возврат """" + Идентификатор + """";
		
	#КонецЕсли
КонецФункции // jsonЗаписатьСсылку()


// ─────────────────────────────────────────────────────────────────────────────
//  ЛОКАЛИЗАЦИЯ

Функция СформироватьСтрокуПоШаблону(Строка, Параметры)
	
	Результат = Строка;
	
	Для Каждого Параметр Из Параметры Цикл
		Результат = СтрЗаменить(Результат, "[" + Параметр.Ключ + "]", Строка(Параметр.Значение));
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // СформироватьСтрокуПоШаблону()


Функция ИсключениеПустойПакетДанных()
	
	Возврат НСтр("ru = 'JSON: Пустой пакет данных.'; uk = 'JSON: Порожній пакет даних.'");
	
КонецФункции // ИсключениеНеожиданноеОкончаниеСтроки()

Функция ИсключениеНекорректныйПакетДанных(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный пакет данных в позиции [Индекс].'; uk = 'JSON: Некоректний пакет даних у позиції [Индекс].'"),
	Новый Структура("Индекс", Индекс));
	
КонецФункции // ИсключениеНекорректныйПакетДанных()

Функция ИсключениеНеожиданноеОкончаниеПакетаДанных()
	
	Возврат НСтр("ru = 'JSON: Неожиданное окончание пакета данных.'; uk = 'JSON: Несподіване закінчення пакета даних.'");
	
КонецФункции // ИсключениеНеожиданноеОкончаниеПакетаДанных()

Функция ИсключениеНеожиданноеОкончаниеМассива(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Неожиданное окончание массива в позиции [Индекс].'; uk = 'JSON: Несподіване закінчення масиву у позиції [Индекс].'"),
	Новый Структура("Индекс", Индекс));
	
КонецФункции // ИсключениеНеожиданноеОкончаниеМассива()

Функция ИсключениеНеожиданноеОкончаниеОбъетка(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Неожиданное окончание объекта в позиции [Индекс].'; uk = 'JSON: Несподіване закінчення об''єкту у позиції [Индекс].'"),
	Новый Структура("Индекс", Индекс));
	
КонецФункции // ИсключениеНеожиданноеОкончаниеОбъетка()

Функция ИсключениеНекорректныйТипNull(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный тип Null в позиции [Индекс].'; uk = 'JSON: Некоректний тип Null у позиції [Индекс].'"),
	Новый Структура("Индекс", Индекс));
	
КонецФункции // ИсключениеНекорректныйТипNull()

Функция ИсключениеНекорректныйТипБулево(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный тип Булево в позиции [Индекс].'; uk = 'JSON: Некоректний тип Булево у позиції [Индекс].'"),
	Новый Структура("Индекс", Индекс));
	
КонецФункции // ИсключениеНекорректныйТипБулево()

Функция ИсключениеНекорректныйТипНеопределено(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный тип Неопределено в позиции [Индекс].'; uk = 'JSON: Некоректний тип Невизначено у позиції [Индекс].'"),
	Новый Структура("Индекс", Индекс));
	
КонецФункции // ИсключениеНекорректныйТипНеопределено()

Функция ИсключениеНекорректныйФорматСтроки(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный формат строки в позиции [Индекс].'; uk = 'JSON: Некоректний формат рядка у позиції [Индекс].'"),
	Новый Структура("Индекс", Индекс));
	
КонецФункции // ИсключениеНекорректныйФорматСтроки()

Функция ИсключениеНекорректныйФорматДаты(Индекс, Значение)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный формат даты [Значение] в позиции [Индекс].'; uk = 'JSON: Некоректний формат дати [Значение] у позиції [Индекс].'"),
	Новый Структура("Индекс", Индекс, Символ(034) + Значение + Символ(034)));
	
КонецФункции // ИсключениеНекорректныйФорматДаты()

Функция ИсключениеНекорректныйФорматЧисла(Индекс, Значение)
	
	Если ПустаяСтрока(Значение) Тогда
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Неверный формат данных в позиции [Индекс].'; uk = 'JSON: Невірний формат даних у позиції [Индекс].'"),
		Новый Структура("Индекс", Индекс));
		
	Иначе
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный формат числа [Значение] в позиции [Индекс].'; uk = 'JSON: Некоректний формат числа [Значение] у позиції [Индекс].'"),
		Новый Структура("Индекс,Значение", Индекс, Символ(034) + Значение + Символ(034)));
		
	КонецЕсли;
	
КонецФункции // ИсключениеНекорректныйФорматЧисла()

Функция ИсключениеНедопустимыйСимвол(Индекс, Символ)
	
	Если (Символ = Неопределено) Тогда
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимый символ в позиции [Индекс].'; uk = 'JSON: Неприпустимий символ в позиції [Индекс].'"),
		Новый Структура("Индекс", Индекс));
		
	Иначе
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимый символ в позиции [Индекс], ожидается [Символ].'; uk = 'JSON: Неприпустимий символ в позиції [Индекс], очікується [Символ].'"),
		Новый Структура("Индекс,Символ", Индекс, Символ(034) + Символ + Символ(034)));
		
	КонецЕсли;
	
КонецФункции // ИсключениеНедопустимыйСимвол()

Функция ИсключениеНеопознанныйТип(Индекс, Тип)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимый тип [Тип] в позиции [Индекс].'; uk = 'JSON: Неприпустимий тип [Тип] у позиції [Индекс].'"),
	Новый Структура("Индекс,Тип", Индекс, Символ(034) + Тип + Символ(034)));
	
КонецФункции // ИсключениеНеопознанныйТип()

Функция ИсключениеНевозможноПреобразоватьЗначение(Индекс, Значение)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Невозможно преобразовать значение [Значение] в позиции [Индекс].'; uk = 'JSON: Неможливо перетворити значення [Значение] у позиції [Индекс].'"),
	Новый Структура("Индекс,Значение", Индекс, Символ(034) + Значение + Символ(034)));
	
КонецФункции // ИсключениеНевозможноПреобразоватьЗначение()

Функция ИсключениеНевозможноПреобразоватьЗначениеНаКлиенте(Индекс, Значение)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Невозможно на клиенте преобразовать значение [Значение] в позиции [Индекс].'; uk = 'JSON: Неможливо на клієнті перетворити значення [Значение] у позиції [Индекс].'"),
	Новый Структура("Индекс,Значение", Индекс, Символ(034) + Значение + Символ(034)));
	
КонецФункции // ИсключениеНевозможноПреобразоватьЗначениеНаКлиенте()

Функция ИсключениеНекорректныйПараметр(Параметр)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимое значение параметра [Параметр].'; uk = 'JSON: Неприпустиме значення параметра [Параметр].'"),
	Новый Структура("Параметр", Символ(034) + Параметр + Символ(034)));
	
КонецФункции // ИсключениеНекорректныйПараметр()

Функция ИсключениеНедопустимыйТипКлюча(Индекс, Значение)
	
	Если (Индекс = Неопределено) Тогда
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимый тип значения ключа [Тип].'; uk = 'JSON: Неприпустимий тип значення ключа [Тип].'"),
		Новый Структура("Тип", ТипЗнч(Значение)));
		
	Иначе
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимый тип значения ключа [Тип] в позиции [Индекс].'; uk = 'JSON: Неприпустимий тип значення ключа [Тип] в позиції [Индекс].'"),
		Новый Структура("Индекс,Тип", Индекс, Символ(034) + ТипЗнч(Значение) + Символ(034)));
		
	КонецЕсли;
	
КонецФункции // ИсключениеНедопустимыйТипКлюча()

Функция ИсключениеНевозможноВыполнитьЗапрос(Описание)
	
	Позиция = Найти(Описание, "}: "); Если Позиция Тогда Позиция = Позиция + 3; Иначе Позиция = 1; КонецЕсли;
	Длина = Найти(Описание, Символы.ПС); Если Длина Тогда Длина = Длина - Позиция; Иначе Длина = СтрДлина(Описание); КонецЕсли;
	Возврат НСтр("ru = 'JSON: Невозможно выполнить запрос. '; uk = 'JSON: Неможливо виконати запит. '") + Сред(Описание, Позиция, Длина) + ".";
	
КонецФункции // ИсключениеНевозможноВыполнитьЗапрос()

Функция ПрочитатьЖСОН(ТекстовыеДанные)
	Если не ЗначениеЗаполнено(ТекстовыеДанные) Тогда
		Возврат Новый Соответствие;
	КонецЕсли;
	
	Возврат ПрочитатьJSON_Обработка(ТекстовыеДанные);
	
	//Чтение = Новый ЧтениеJSON;
	//Чтение.УстановитьСтроку(ТекстовыеДанные);
	//
	//Попытка
	//
	//	Итоговое = ПрочитатьJSON(Чтение,Истина);
	//
	//Исключение
	//	
	//	Итоговое = Новый Соответствие;
	//	Сообщить(ОписаниеОшибки()+СокрЛП(ТекстовыеДанные));
	//	
	//КонецПопытки;
	//
	//Возврат Итоговое;
	
КонецФункции

Функция ЗаписатьЖСОН(ИсходныеДанные)
	
	Возврат ЗаписатьJSON_Обработка(ИсходныеДанные);
	//
	//ЗаписьJ = Новый ЗаписьJSON;
	//ЗаписьJ.УстановитьСтроку();
	//Попытка
	//	ЗаписатьJSON(ЗаписьJ,ИсходныеДанные);
	//Исключение
	//	ИсходныеДанные = ОписаниеОшибки();
	//КонецПопытки;
	//ИтоговыеДанные = ЗаписьJ.Закрыть();
	//
	//Возврат ИтоговыеДанные;
	//
КонецФункции

#КонецОбласти

#Область ОбработкаЗапросов

Процедура  ОбработкаЗапросов(ФонофоеЗадание = Ложь) Экспорт 
	
	ПрочитатьНастройки();
	
	Если НЕ ЗначениеЗаполнено(КлючАПИ) Тогда
		Возврат;
	КонецЕсли;
	
	ПолучитьUpdate();
	СформироватьЗадачиНаПодтверждение();
	ОбработатьЗапросы();
	
	Если НЕ ФонофоеЗадание Тогда
		ЗаписатьНастройки();
	КонецЕсли;
	
КонецПроцедуры

Процедура СформироватьЗадачиНаПодтверждение()
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ТелеграмЗадачиПодтверждения.ОбъектПодтверждения КАК ОбъектПодтверждения,
	|	ТелеграмЗадачиПодтверждения.Статус,
	|	ТелеграмЗадачиПодтверждения.ФизЛицоПодтверждения КАК ФизЛицоПодтверждения,
	|	ТелеграмЗадачиПодтверждения.ИДПользователяПодтверждения,
	|	ЕСТЬNULL(ТелеграмПользователи.Имя, """") КАК Имя,
	|	ЕСТЬNULL(ТелеграмПользователи.Фамилия, """") КАК Фамилия,
	|	ЕСТЬNULL(ТелеграмПользователи.ЮзерНайм, """") КАК ЮзерНайм
	|ИЗ
	|	РегистрСведений.ТелеграмЗадачиПодтверждения КАК ТелеграмЗадачиПодтверждения
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ТелеграмПользователи КАК ТелеграмПользователи
	|		ПО ТелеграмЗадачиПодтверждения.ФизЛицоПодтверждения = ТелеграмПользователи.ФизЛицо
	|			И ТелеграмЗадачиПодтверждения.ИДПользователяПодтверждения = ТелеграмПользователи.ИДПользователя
	|ГДЕ
	|	ТелеграмЗадачиПодтверждения.Статус = ЗНАЧЕНИЕ(Перечисление.СтатусыЗадачПодтвержденияТелеграм.ВОжидании)
	|	И ТелеграмЗадачиПодтверждения.ФизЛицоПодтверждения <> &ФизЛицоПодтверждения
	|	И ТелеграмЗадачиПодтверждения.ИДПользователяПодтверждения <> &ИДПользователяПодтверждения
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбъектПодтверждения
	|ИТОГИ ПО
	|	ФизЛицоПодтверждения
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТелеграмЗадачиПодтверждения.ОбъектПодтверждения,
	|	ТелеграмЗадачиПодтверждения.Статус,
	|	ТелеграмЗадачиПодтверждения.ФизЛицоПодтверждения,
	|	ТелеграмЗадачиПодтверждения.ИДПользователяПодтверждения
	|ИЗ
	|	РегистрСведений.ТелеграмЗадачиПодтверждения КАК ТелеграмЗадачиПодтверждения
	|ГДЕ
	|	ТелеграмЗадачиПодтверждения.Статус = ЗНАЧЕНИЕ(Перечисление.СтатусыЗадачПодтвержденияТелеграм.Обрабатывается)
	|	И ТелеграмЗадачиПодтверждения.ФизЛицоПодтверждения <> &ФизЛицоПодтверждения
	|	И ТелеграмЗадачиПодтверждения.ИДПользователяПодтверждения <> &ИДПользователяПодтверждения";
	Запрос.УстановитьПараметр("ФизЛицоПодтверждения", Справочники.ФизическиеЛица.ПустаяСсылка());
	Запрос.УстановитьПараметр("ИДПользователяПодтверждения", "");
	
	Пакет = Запрос.ВыполнитьПакет();
	
	ВыборкаПоПользователям = Пакет[0].Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	ТаблицаВОбработке = Пакет[1].Выгрузить();
	
	//Запрос для проверки существующих задач пользователя
	ЗапросПользователя = Новый Запрос;
	ЗапросПользователя.Текст = 
	"ВЫБРАТЬ
	|	ТелеграмЗапросы.update_id,
	|	ТелеграмЗапросы.message_id
	|ИЗ
	|	РегистрСведений.ТелеграмЗапросы КАК ТелеграмЗапросы
	|ГДЕ
	|	ТелеграмЗапросы.id = &id
	|	И НЕ ТелеграмЗапросы.Обработан";

	Пока ВыборкаПоПользователям.Следующий() Цикл
		Если ТаблицаВОбработке.НайтиСтроки(Новый Структура("ФизЛицоПодтверждения", ВыборкаПоПользователям.ФизЛицоПодтверждения)).Количество() Тогда
			Продолжить;
		КонецЕсли;
		
		ВыборкаКФормированию = ВыборкаПоПользователям.Выбрать();
		Если ВыборкаКФормированию.Следующий() Тогда
			//проверим есть ли уже задачи этому пользователю, чтобы избежать накладок
			ЗапросПользователя.УстановитьПараметр("id", ВыборкаКФормированию.ИДПользователяПодтверждения);
			Результат = ЗапросПользователя.Выполнить().Выбрать();
			
			Если НЕ Результат.Следующий() Тогда
				Запись = РегистрыСведений.ТелеграмЗапросы.СоздатьМенеджерЗаписи();
				Запись.id = ВыборкаКФормированию.ИДПользователяПодтверждения;
				Запись.first_name = ВыборкаКФормированию.Имя;
				Запись.last_name = ВыборкаКФормированию.Фамилия;
				Запись.username = ВыборкаКФормированию.ЮзерНайм;
				Запись.text = "/согласовать";
				Запись.date = ТекущаяДата();
				Запись.ОбрабатываемаяЗадача = ВыборкаКФормированию.ОбъектПодтверждения;
				Запись.Записать(Истина);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция НайтиЗадачуПодтвержденияПользователя(ИДПользователяПодтверждения)
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ТелеграмЗадачиПодтверждения.ОбъектПодтверждения
	|ИЗ
	|	РегистрСведений.ТелеграмЗадачиПодтверждения КАК ТелеграмЗадачиПодтверждения
	|ГДЕ
	|	ТелеграмЗадачиПодтверждения.Статус = ЗНАЧЕНИЕ(Перечисление.СтатусыЗадачПодтвержденияТелеграм.Обрабатывается)
	|	И ТелеграмЗадачиПодтверждения.ИДПользователяПодтверждения = &ИДПользователяПодтверждения";
	Запрос.УстановитьПараметр("ИДПользователяПодтверждения", ИДПользователяПодтверждения);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ОбъектПодтверждения;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

Процедура УдалитьЗадачуПодтверждения(Задача)
	Набор = РегистрыСведений.ТелеграмЗадачиПодтверждения.СоздатьНаборЗаписей();
	Набор.Отбор.ОбъектПодтверждения.Установить(Задача);
	Набор.Записать();
КонецПроцедуры

Функция ПолучитьПрокси()
	
	Прокси = Новый ИнтернетПрокси(УказатьПрокси);
	
	Если УказатьПрокси Тогда
		Прокси.Установить("https",АдресПрокси,ПортПрокси,ЛогинПрокси,ПарольПрокси);
	КонецЕсли;
	
	Возврат Прокси;
	
КонецФункции

Процедура ПолучитьUpdate() Экспорт 
	
	Если ЗначениеЗаполнено(ОбработанныйНомер) ТОгда
		OffSet = "?offset="+Формат(ОбработанныйНомер, "ЧГ=");
	Иначе
		OffSet = "";
	КонецЕсли;
	
	Прокси = ПолучитьПрокси();
	
	Сервер = "api.telegram.org";
	Команда = "getUpdates"+OffSet;
	Ресурс = "bot"+КлючАПИ+"/"+Команда;
	Соединение = Новый HTTPСоединение(Сервер,,,,Прокси,,Новый ЗащищенноеСоединениеOpenSSL);
	Запрос = Новый HTTPЗапрос(Ресурс); 
	
	Ответ = Соединение.Получить(Запрос);
	
	ОтветСтруктурой = ПрочитатьЖСОН(Ответ.ПолучитьТелоКакСтроку());
	Если ОтветСтруктурой.Получить("ok") = Истина Тогда
		getUpdatesОбОтв(ОтветСтруктурой);
	КонецЕсли;
	
	Соединение = Неопределено;
	
КонецПроцедуры

Процедура getUpdatesОбОтв(Ответ)
	
	Для Каждого стрОтвет Из Ответ["result"] Цикл
				
		НаборЗаписей = РегистрыСведений.ТелеграмЗапросы.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.update_id.Установить(стрОтвет["update_id"]);
		НаборЗаписей.Прочитать();
		Если НЕ НаборЗаписей.Количество() Тогда
			Запись = НаборЗаписей.Добавить();
			Сообщение = стрОтвет["message"];
			
			Если Сообщение = Неопределено Тогда
				Сообщение = стрОтвет["edited_message"];
			КонецЕсли;
			
			Запись.update_id = стрОтвет["update_id"];
			Запись.date = МестноеВремя(Дата('19700101')+Сообщение["date"]);
			Запись.text = Сообщение["text"];
			Запись.message_id 	= Сообщение["message_id"];
			Запись.first_name 	= Сообщение["from"]["first_name"];
			Запись.last_name 	= Сообщение["from"]["last_name"];
			Запись.username 	= Сообщение["from"]["username"];
			Запись.id 			= Сообщение["from"]["id"];
			НаборЗаписей.Записать(Истина);
		КонецЕсли;
		
		ОбработанныйНомер = Макс(ОбработанныйНомер, стрОтвет["update_id"] + 1); 
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбработатьЗапросы() Экспорт
	
	Запрос = Новый Запрос("ВЫБРАТЬ
	                      |	ТелеграмЗапросы.update_id,
	                      |	ТелеграмЗапросы.date,
	                      |	ТелеграмЗапросы.text,
	                      |	ТелеграмЗапросы.message_id КАК message_id,
	                      |	ТелеграмЗапросы.first_name,
	                      |	ТелеграмЗапросы.id КАК id,
	                      |	ТелеграмЗапросы.last_name,
	                      |	ТелеграмЗапросы.username КАК ЮзерНайм,
	                      |	ТелеграмЗапросы.Обработан КАК Обработан,
	                      |	ТелеграмЗапросы.ОбрабатываемаяЗадача,
	                      |	ТелеграмЗапросы.ПроизвольныйЗапрос
	                      |ИЗ
	                      |	РегистрСведений.ТелеграмЗапросы КАК ТелеграмЗапросы
	                      |ГДЕ
	                      |	НЕ ТелеграмЗапросы.Обработан
	                      |
	                      |УПОРЯДОЧИТЬ ПО
	                      |	message_id
	                      |ИТОГИ ПО
	                      |	id");
	
	ВыборкаЮзеров = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаЮзеров.Следующий() Цикл
		
		ВыборкаЗапросов = ВыборкаЮзеров.Выбрать();
		Если ВыборкаЗапросов.Следующий() Тогда
			Обработан = Ложь;
			Ответ = Неопределено;
			ОбработатьЗапрос(ВыборкаЗапросов, Обработан, Ответ);
			//ОбработанныйНомер = Макс(ОбработанныйНомер,ВыборкаЗапросов.update_id);
		КонецЕсли;
		
		Если Обработан Тогда
			Если ВыборкаЗапросов.ПроизвольныйЗапрос Тогда
				result = Ответ["result"];
				message_id = result["message_id"];
				Запись = РегистрыСведений.ТелеграмЗапросы.СоздатьМенеджерЗаписи();
				ЗаполнитьЗначенияСвойств(Запись, ВыборкаЗапросов);
				Запись.username = ВыборкаЗапросов.ЮзерНайм;
				Запись.Обработан = Истина;
				Запись.message_id = message_id;
				Запись.Записать(Истина);
				
				Если message_id Тогда
					УдалитьДанныеЗапроса(ВыборкаЗапросов);
				КонецЕсли;
			Иначе
				ИзменитьДанныеЗапроса(ВыборкаЗапросов, "Обработан", Истина);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	//Если ВыборкаЮзеров.Количество()>0 Тогда
	//	ОбработанныйНомер = ОбработанныйНомер+1;
	//КонецЕсли;
	
	//Запросы.Очистить();
	
КонецПроцедуры

Процедура ОбработатьЗапрос(ЗапросПользователя, ok, Ответ)
	
	СтрокаПользователя = ПолучитьСтрокуПользователя(ЗапросПользователя);
	
	ТекстЗапроса =НРег(ЗапросПользователя.text);
	
	СтруктураСообщения = Новый Структура;
	СтруктураСообщения.Вставить("chat_id",Формат(ЗапросПользователя.id,"ЧГ="));
	
	ОтправитьФайл = "";
	
	ОбрабатыватьМеню = Ложь;
	
	Если ТекстЗапроса = "стоп" или ТекстЗапроса = "/стоп" или ТекстЗапроса = "/stop" или ТекстЗапроса = "/с" или ТекстЗапроса = "/c" Тогда
		
		Если СтрокаПользователя.СозданиеНовойЗадачи Тогда 
			СтруктураСообщения.Вставить("text","Создание задачи прекращено.");
			ОчисткаСозданияЗадачПользователем(СтрокаПользователя);
		Иначе	
			СтруктураСообщения.Вставить("text","ok.");
		КонецЕсли;
		
	ИначеЕсли ТекстЗапроса = "помощь" или ТекстЗапроса = "/help" или ТекстЗапроса = "/h" или ТекстЗапроса = "/х" или
		ТекстЗапроса = "help"  или ТекстЗапроса = "h" или ТекстЗапроса = "x" Тогда
		
		СтруктураСообщения.Вставить("text",Помощь);
	ИначеЕсли ТекстЗапроса = "/согласовать" Тогда
		
		Если Не ЗначениеЗаполнено(ЗапросПользователя.ОбрабатываемаяЗадача) Тогда
			СтруктураСообщения.Вставить("text", "Неуказана задача для согласования");
		Иначе
			Задача = ЗапросПользователя.ОбрабатываемаяЗадача;
			ТекстСообщения = "Согласуйте задачу №" + Задача.Номер + Символы.ПС + 
				"Автор: " + Задача.Автор + Символы.ПС + 
				"Заголовок: " + Задача.Заголовок + Символы.ПС + 
				"Описание: " + Задача.Описание + Символы.ПС + 
				"Объем часов: " + Задача.ОбъемЧасов + Символы.ПС + 
				"Стоимость работ: " + Задача.СтоимостьРабот + Символы.ПС + 
				"Исполнитель: " + Задача.ТекущийИсполнитель;
				
			СтруктураСообщения.Вставить("text",ТекстСообщения);
			МассивКнопок = Новый Массив;
			МассивКнопок.Добавить("/подтвердить");
			МассивКнопок.Добавить("/отменить");
			
			СтруктураСообщения.Вставить("reply_markup",ПолучитьСтруктуруКнопок(МассивКнопок));
			
			ИзменитьДанныеЗадачиНаПодтверждение(Задача, "Статус", Перечисления.СтатусыЗадачПодтвержденияТелеграм.Обрабатывается);
		КонецЕсли;
		
	ИначеЕсли ТекстЗапроса = "/подтвердить" или ТекстЗапроса = "/отменить"Тогда
		ЗадачанаПодтверждение = НайтиЗадачуПодтвержденияПользователя(ЗапросПользователя.id);
		ТекстСообщения = "";
		
		Если НЕ ЗначениеЗаполнено(ЗадачанаПодтверждение) Тогда
			ТекстСообщения = "Неуказана задача для подтверждения или отмены";
		ИначеЕсли ТекстЗапроса = "/подтвердить" Тогда
			ДокОбъект = ЗадачанаПодтверждение.ПолучитьОбъект();
			ДокОбъект.ТекущийСтатус = Справочники.Статусы.ВРаботе;
			ДобавитьВЗадачуИзменениеИстории(ДокОбъект, Справочники.Статусы.ВРаботе, СтрокаПользователя.ФизЛицо); 
			ДокОбъект.Записать();
			
			ТекстСообщения = "Задача №" + ЗадачанаПодтверждение.Номер + " была запущена в работу";
			УдалитьЗадачуПодтверждения(ЗадачанаПодтверждение);
		ИначеЕсли ТекстЗапроса = "/отменить" Тогда
			ДокОбъект = ЗадачанаПодтверждение.ПолучитьОбъект();
			ДокОбъект.ТекущийСтатус = Справочники.Статусы.ОтмененаЗаказчиком;
			ДобавитьВЗадачуИзменениеИстории(ДокОбъект, Справочники.Статусы.ОтмененаЗаказчиком, СтрокаПользователя.ФизЛицо); 
			ДокОбъект.Записать();
			
			ТекстСообщения = "Задача №" + ЗадачанаПодтверждение.Номер + " была отменена";
			УдалитьЗадачуПодтверждения(ЗадачанаПодтверждение);
		КонецЕсли;
		
		СтруктураСообщения.Вставить("text",ТекстСообщения);
		
	ИначеЕсли ТекстЗапроса = "/newtask" или ТекстЗапроса = "/nt" или ТекстЗапроса = "/новаязадача" или ТекстЗапроса = "/нз" Тогда
		
		РазрешеноСоздаватьЗадачи = Ложь;
		Если ЗначениеЗаполнено(СтрокаПользователя.ФизЛицо) Тогда
			Отдел = РаботаСБотомТелеграм.НайтиОтделПоОтветственному(СтрокаПользователя.ФизЛицо);
			Если ЗначениеЗаполнено(Отдел) Тогда
				РазрешеноСоздаватьЗадачи = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если РазрешеноСоздаватьЗадачи Тогда
			СтруктураСообщения.Вставить("text","Введите заголовок новой задачи:");
			ИзменитьДанныеПользователя(СтрокаПользователя, "СозданиеНовойЗадачи", Истина);
			СтруктураСообщения.Вставить("reply_markup",ПолучитьСтруктуруКнопок(Новый Массив, Истина));
		Иначе
			СтруктураСообщения.Вставить("text","Создание задач для вас не предвидено. Вы не являетесь ответственным лицом отдела.");
		КонецЕсли;
		
	ИначеЕсли ВключитьЗаглушку Тогда
		
		СтруктураСообщения.Вставить("text",ТекстЗаглушки);
		
	ИначеЕсли не СтрокаПользователя.Подтвержден Тогда
		
		Если СокрЛП(ТекстЗапроса) = Формат(СтрокаПользователя.КодПодтверждения,"ЧГ=0") Тогда
			
			ИзменитьДанныеПользователя(СтрокаПользователя, "Подтвержден", Истина);
			
			ТекстСообщения ="ПИН-код подтвержден!";
			СтруктураСообщения.Вставить("text",ТекстСообщения);
			
		Иначе
			
			ТекстСообщения ="Введите ПИН-код";
			СтруктураСообщения.Вставить("text",ТекстСообщения);
			
			РаботаСБотомТелеграм.РегистрацияНовогоПользователяТелеграма(СтрокаПользователя.ИДПользователя, СтрокаПользователя.Имя,
				СтрокаПользователя.Фамилия, СтрокаПользователя.ЮзерНайм, СтрокаПользователя.КодПодтверждения);
		КонецЕсли;
		
	ИначеЕсли ЗапросПользователя.ПроизвольныйЗапрос Тогда
		СтруктураСообщения.Вставить("text",ТекстЗапроса);
		СтруктураСообщения.Вставить("reply_markup",ПолучитьСтруктуруКнопок(Новый Массив, Истина));
	Иначе
		Если СтрокаПользователя.СозданиеНовойЗадачи Тогда 
			Если НЕ ЗначениеЗаполнено(СокрЛП(ТекстЗапроса)) Тогда
				СтруктураСообщения.Вставить("text","Значение не может быть пустым. Повторите ввод:");
			ИначеЕсли НЕ ЗначениеЗаполнено(СтрокаПользователя.Заголовок) Тогда 
				ИзменитьДанныеПользователя(СтрокаПользователя, "Заголовок", ТекстЗапроса);
				СтруктураСообщения.Вставить("text","Введите описание новой задачи:");
				СтруктураСообщения.Вставить("reply_markup",ПолучитьСтруктуруКнопок(Новый Массив, Истина));
			ИначеЕсли НЕ ЗначениеЗаполнено(СтрокаПользователя.Описание) Тогда 
				ИзменитьДанныеПользователя(СтрокаПользователя, "Описание", ТекстЗапроса);
				СтруктураСообщения.Вставить("text","Выберите исполнителя:");
				МассивИсполнителей = ПолучитьМасивИсполнителей();
				СтруктураСообщения.Вставить("reply_markup",ПолучитьСтруктуруКнопок(МассивИсполнителей, Истина));
			ИначеЕсли ЗначениеЗаполнено(СтрокаПользователя.Заголовок) И ЗначениеЗаполнено(СтрокаПользователя.Описание) Тогда 
				
				//Поиск исполнителя по наименованию
				ИсполнительНайден = Ложь;
				Исполнитель = Справочники.ФизическиеЛица.НайтиПоНаименованию(ТекстЗапроса);
				Если ЗначениеЗаполнено(Исполнитель) И Исполнитель.ВыполняетРаботы Тогда
					ИсполнительНайден = Истина;
				КонецЕсли;
				
				Если НЕ ИсполнительНайден Тогда
					СтруктураСообщения.Вставить("text", "Такого исполнителя не существует!"+Символы.ПС+"Выберите исполнителя:");
					МассивИсполнителей = ПолучитьМасивИсполнителей();
					СтруктураСообщения.Вставить("reply_markup",ПолучитьСтруктуруКнопок(МассивИсполнителей, Истина));
					Перейти ~Метка_ОтправкаСообщения;
				КонецЕсли;
				
				//Проверим, не забрали ли у пользователя права на создание задачи
				РазрешеноСоздаватьЗадачи = Ложь;
				Если ЗначениеЗаполнено(СтрокаПользователя.ФизЛицо) Тогда
					Отдел = РаботаСБотомТелеграм.НайтиОтделПоОтветственному(СтрокаПользователя.ФизЛицо);
					Если ЗначениеЗаполнено(Отдел) Тогда
						РазрешеноСоздаватьЗадачи = Истина;
					КонецЕсли;
				КонецЕсли;

				Если НЕ РазрешеноСоздаватьЗадачи Тогда
					СтруктураСообщения.Вставить("text","В процессе были отобраны права на создание задачи.");
					ОчисткаСозданияЗадачПользователем(СтрокаПользователя);
					Перейти ~Метка_ОтправкаСообщения;
				КонецЕсли;
				
				НоваяЗадача = Документы.ОбращениеВПоддержку.СоздатьДокумент();
				НоваяЗадача.Дата		= ТекущаяДата();
				НоваяЗадача.Автор		= СтрокаПользователя.ФизЛицо;
				НоваяЗадача.Заголовок	= СтрокаПользователя.Заголовок;
				НоваяЗадача.Описание	= СтрокаПользователя.Описание;
				НоваяЗадача.Важность	= Перечисления.ВидВажности.Обычная;
				НоваяЗадача.ТекущийСтатус		= Справочники.Статусы.Новое;
				НоваяЗадача.ТекущийИсполнитель	= Справочники.ФизическиеЛица.НайтиПоКоду("000000001");
				НоваяЗадача.РеальныйИсполнитель	= Исполнитель;
				НоваяЗадача.ОбращениеОт			= Отдел;
				ДобавитьВЗадачуИзменениеИстории(НоваяЗадача, Справочники.Статусы.Новое, СтрокаПользователя.ФизЛицо); 
				НоваяЗадача.Записать(РежимЗаписиДокумента.Проведение);
				
				СтруктураСообщения.Вставить("text","Была создана новая задача №"+НоваяЗадача.Номер);
				ПолучитьСтруктуруКнопок(Новый Массив,, Ложь);
				ОчисткаСозданияЗадачПользователем(СтрокаПользователя);
			КонецЕсли;
			
			Если ЗначениеЗаполнено(ЗапросПользователя.message_id) Тогда
				
				СтруктураСообщения.Вставить("reply_to_message_id",Формат(ЗапросПользователя.message_id,"ЧГ=0"));
				
			КонецЕсли;
		Иначе
			ok = Истина;
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
~Метка_ОтправкаСообщения:	

	ИмяФайлаОтправки ="";
	ЗаголовокФайла = "";
	
	//Если ОбрабатыватьМеню Тогда
	//	
	//	СтруктураМеню = ПолучитьДоступноеМеню(СтрокаПользователя,ЗапросПользователя); 
	//	СтруктураСообщения.Вставить("text",СтруктураМеню.text);
	//	
	//	СтруктураМеню.Свойство("ИмяФайла",ИмяФайлаОтправки);
	//	СтруктураМеню.Свойство("ЗаголовокФайла",ЗаголовокФайла);
	//	
	//	СтруктураКнопкоМеню = Новый Структура;
	//	СтруктураКнопкоМеню.Вставить("resize_keyboard",true);
	//	СтруктураКнопкоМеню.Вставить("one_time_keyboard",true);
	//	СтруктураКнопкоМеню.Вставить("keyboard", ПолучитьМассивРазложенныхКропок(СтруктураМеню.МассивКнопок));
	//	
	//	СтруктураСообщения.Вставить("reply_markup",СтруктураКнопкоМеню);
	//	
	//	Если ЗначениеЗаполнено(ЗапросПользователя.message_id) Тогда
	//		
	//		СтруктураСообщения.Вставить("reply_to_message_id",Формат(ЗапросПользователя.message_id,"ЧГ=0"));
	//		
	//	КонецЕсли;
	//	
	//	//СтрокаПользователя.ДатаПоследнегоЗапроса=ТекущаяДата();
	//	ИзменитьДанныеПользователя(СтрокаПользователя, "ДатаПоследнегоЗапроса", ТекущаяДата());
	//	
	//	
	//КонецЕсли;
	
	Если ЗначениеЗаполнено(РекламаСообщения) Тогда
		СтруктураСообщения.text = РекламаСообщения+Символы.ПС+СтруктураСообщения.text;
	КонецЕсли;
	
	ИзменитьДанныеПользователя(СтрокаПользователя, "ДатаПоследнегоЗапроса", ТекущаяДата());
	
	ОтправитьСообщение(СтруктураСообщения, ok,ИмяФайлаОтправки,ЗаголовокФайла, Ответ);
	
КонецПроцедуры

Процедура ДобавитьВЗадачуИзменениеИстории(ДокОбъект, Статус = Неопределено, ФизЛицо = Неопределено)
	НоваяСтрока = ДокОбъект.Статусы.Добавить();
	НоваяСтрока.Дата = ТекущаяДата();
	НоваяСтрока.Статус = Статус;
	НоваяСтрока.Добавил = ФизЛицо;
КонецПроцедуры
			
Функция ПолучитьМасивИсполнителей()
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ФизическиеЛица.Наименование
	|ИЗ
	|	Справочник.ФизическиеЛица КАК ФизическиеЛица
	|ГДЕ
	|	ФизическиеЛица.ВыполняетРаботы";
	Результат = Запрос.Выполнить().Выгрузить();
	
	Возврат Результат.ВыгрузитьКолонку("Наименование");
КонецФункции

Процедура ОчисткаСозданияЗадачПользователем(СтрокаПользователя)
	ИзменитьДанныеПользователя(СтрокаПользователя, "СозданиеНовойЗадачи", Ложь);
	ИзменитьДанныеПользователя(СтрокаПользователя, "Заголовок", "");
	ИзменитьДанныеПользователя(СтрокаПользователя, "Описание", "");
КонецПроцедуры

Функция ПолучитьСтруктуруКнопок(Массив, ИспользоватьКнопкуСтоп = Ложь, ВыводКнопок = Истина)
	СтруктураКнопкоМеню = Новый Структура;
	СтруктураКнопкоМеню.Вставить("resize_keyboard",ВыводКнопок);
	СтруктураКнопкоМеню.Вставить("one_time_keyboard",ВыводКнопок);
	СтруктураКнопкоМеню.Вставить("keyboard", ПолучитьМассивРазложенныхКропок(Массив, ИспользоватьКнопкуСтоп));
	
	Возврат СтруктураКнопкоМеню;
КонецФункции

Функция ПолучитьМассивРазложенныхКропок(знач МассивКнопок, ИспользоватьКнопкуСтоп = Ложь)
	ИтоговыйМассив = Новый Массив;
	
	Если ИспользоватьКнопкуСтоп Тогда
		МассивКнопок.Добавить("Стоп");
	КонецЕсли;
	
	ТекКоличествоКнопок = КоличествоКнопокВРяду;
	
	Если ТекКоличествоКнопок<=0 Тогда
		ТекКоличествоКнопок=2;
	КонецЕсли;
	
	ТекКолВряду =0;
	
	текМассивСКнопками = Новый Массив;
	для Каждого стр из МассивКнопок Цикл 
		
		Если ТекКолВряду< ТекКоличествоКнопок Тогда
			
			ТекКолВряду = ТекКолВряду+1;
			
		Иначе 
			
			ТекКолВряду = 0;
			ИтоговыйМассив.Добавить(текМассивСКнопками);
			текМассивСКнопками = Новый Массив;
		КонецЕсли;
		
		текМассивСКнопками.Добавить(стр);
		
		
	КонецЦикла;
	Если текМассивСКнопками.Количество()>0 Тогда
		ИтоговыйМассив.Добавить(текМассивСКнопками);
	КонецЕсли;
	
	
	Возврат ИтоговыйМассив;
	
КонецФункции

Процедура РазослатьСообщение() Экспорт 
	
	для Каждого стр из ЭтотОбъект.Пользователи Цикл 
		
		Если РежимРассылки =0 Тогда
			
		ИначеЕсли РежимРассылки =1 Тогда
			
			Если НЕ стр.Подтвержден Тогда
				Продолжить;
			КонецЕсли;
			
		ИначеЕсли РежимРассылки =2 Тогда
			
			Если стр.Подтвержден Тогда
				Продолжить;
			КонецЕсли;
			
		Иначе
			Возврат;
		КонецЕсли;
		
		СтрукутраОтправки = Новый Структура;
		СтрукутраОтправки.Вставить("text",ТекстРассылки);
		СтрукутраОтправки.Вставить("chat_id",стр.ИДПользователя);
				
		ОтправитьСообщение(СтрукутраОтправки,Истина);
		
	КонецЦикла;
	
КонецПроцедуры
	
Функция УПользователяЕстьПраваНаПункт(РолиПроверки,РолиПользователя)
	Итог = Ложь;	
	
	Если не ЗначениеЗаполнено(РолиПроверки) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если не ЗначениеЗаполнено(РолиПользователя) Тогда
		Возврат Ложь;
	КонецЕсли;
	СписокЗначенийРолейПользователя = Новый СписокЗначений;
	СписокЗначенийРолейПользователя.ЗагрузитьЗначения(РазложитьСтрокуВМассивПодстрок(РолиПользователя,"|"));
	СписокЗначенийПроверки = Новый СписокЗначений;
	СписокЗначенийПроверки.ЗагрузитьЗначения(РазложитьСтрокуВМассивПодстрок(РолиПроверки,"|"));
	для Каждого стр из СписокЗначенийРолейПользователя Цикл 
		стр.Значение = СокрЛП(стр.Значение);	
	КонецЦикла;
	для Каждого стр из СписокЗначенийПроверки Цикл 
		стр.Значение = СокрЛП(стр.Значение);	
	КонецЦикла;
	
	для Каждого стр из СписокЗначенийПроверки Цикл 
		
		Если НЕ СписокЗначенийРолейПользователя.НайтиПоЗначению(стр.Значение)	= Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	
	
	Возврат Итог;
КонецФункции

Функция ТекКомандаПодменю(ТекстЗапроса)
	
	Если Лев(ТекстЗапроса,1) ="/" Тогда
		ПоискРазделителяКоманды = Найти(ТекстЗапроса,"-");
		
		Если ПоискРазделителяКоманды>0 Тогда
			ТекстКоманды = СтрЗаменить(Лев(ТекстЗапроса,ПоискРазделителяКоманды-1),"/","");
		Иначе 
			ТекстКоманды = СтрЗаменить(ТекстЗапроса,"/","");
		КонецЕсли;
		
		Попытка
			Возврат Число(ТекстКоманды);
		Исключение
			Возврат -1;
		КонецПопытки;
	Иначе 
		Возврат -1;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьДоступноеМеню(СтрокаПользователя,ЗапросПользователя)
	
	ТекстЗапроса =НРег(ЗапросПользователя.text);
	
	ИтоговоеМеню = Новый Структура;
	ИтоговоеМеню.Вставить("text","");
	
	ТекСообщение 	= "";
	ИмяФайла		= "";
	ЗаголовокФайла	= "";
	
	МассивКнопок = Новый Массив;
		
	МассивШагов = РазложитьСтрокуВМассивПодстрок(СтрокаПользователя.ТекущийУзел,"_");
	
	ТекДанныеУровня = Меню.Строки;
	
	ОпределенТекущийУровень = Истина;
	для Каждого стр из МассивШагов Цикл 
		
		Попытка
			
			ТекСтрокаДерева = ТекДанныеУровня.Получить(Число(стр)-1);
			
		Исключение
			
			ОпределенТекущийУровень = Ложь;
			ТекСообщение="Нет доступа к данному пункту";
			Прервать;
		КонецПопытки;
		
		Если УПользователяЕстьПраваНаПункт(ТекСтрокаДерева.Роли,СтрокаПользователя.Роли) Тогда
			
			ТекДанныеУровня = ТекСтрокаДерева.Строки;
			
		Иначе 
			
			ОпределенТекущийУровень = Ложь;
			ТекСообщение="Нет доступа к данному пункту";
			
		КонецЕсли;
		
	КонецЦикла;
	
	ТекСтрокаДейстий = Неопределено;
	ЗаголовокКоманды = "Выбор меню:";
	
	Если НЕ ОпределенТекущийУровень Тогда
		ТекДанныеУровня = ТекСтрокаДерева.Строки;
	КонецЕсли;
	
	
	Если ЗначениеЗаполнено(ТекДанныеУровня.Родитель) Тогда
		
		ЗаголовокКоманды = "Меню """+ТекДанныеУровня.Родитель.Название+""" :";
		
	КонецЕсли;
	
	ЗапрашиваемаяКоманда 	= ТекКомандаПодменю(ТекстЗапроса);
	
	КоличествоУровней =ТекДанныеУровня.Количество();
	// Есть еще подменю
	Если КоличествоУровней >0 Тогда
		
		Если ЗапрашиваемаяКоманда>0 И ЗапрашиваемаяКоманда<=КоличествоУровней Тогда
			
			ПолучаемыйУровень = ТекДанныеУровня.Получить(ЗапрашиваемаяКоманда-1);
			
			Если  УПользователяЕстьПраваНаПункт(ПолучаемыйУровень.Роли,СтрокаПользователя.Роли) Тогда
				
				ОчиститьТекущийУровень();
				СтрокаПользователя.ТекущийУзел = ПолучаемыйУровень.Узел; 
				
				ТекДанныеУровня =  ПолучаемыйУровень.Строки;
				ЗаголовокКоманды = "Меню """+ТекДанныеУровня.Родитель.Название+""" :";
				
			КонецЕсли;
			
			
		КонецЕсли;
		
		Для Каждого стр из ТекДанныеУровня Цикл 
			
			Если НЕ УПользователяЕстьПраваНаПункт(стр.Роли,СтрокаПользователя.Роли) Тогда
				Продолжить;	
			КонецЕсли;
			
			СообщениеЦикла = "/"+Формат(ТекДанныеУровня.Индекс(стр)+1)+"- "+стр.Название;
			ТекСообщение = ТекСообщение+?(ЗначениеЗаполнено(ТекСообщение),Символы.ПС,"")+СообщениеЦикла;
			МассивКнопок.Добавить(СообщениеЦикла);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если ТекДанныеУровня.Количество()=0 Тогда
		ТекСтрокаДейстий = ТекДанныеУровня.Родитель;
	КонецЕсли;
	
	СтркутраДанных = Новый Структура;
	СтркутраДанных.Вставить("Сообщение","");
	СтркутраДанных.Вставить("Клавиатура",Новый Массив);
	
	Если НЕ ТекСтрокаДейстий = Неопределено  Тогда
		
		ЗаголовокКоманды = ТекСтрокаДейстий.Название;
		
		Если ТекСтрокаДейстий.ТипДействия = "Сформировать отчет" Тогда
			
			Если ЗначениеЗаполнено(СтрокаПользователя.ТекДанныеУзла) Тогда
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций(ЗапросПользователя.text);
				
			Иначе 
				СхемаОтчета 		= Неопределено;
				ВариантОтчета 		= Неопределено;
				НастройкиКомпановки = Неопределено;
				
				ЗаполнятьСтруктуру 	= Истина;
				ИмяВариантОтчета 	= ТекСтрокаДейстий.ДанныеФормирования;
				
				МетаВариант = Метаданные.Справочники.Найти("ВариантыОтчетов");
				
				Если НЕ МетаВариант=Неопределено Тогда
					
					ВариантОтчета = Справочники[МетаВариант.Имя].НайтиПоНаименованию(ИмяВариантОтчета);
					Если ЗначениеЗаполнено(ВариантОтчета) Тогда
						
						ИмяРеквизитаХраненияНастроек ="ХранилищеЗначений"; 
						ИмяОтчетаСистемное ="";
						Попытка
							ИмяОтчетаСистемное = СтрЗаменить(ВариантОтчета.КлючОбъекта,"Отчет.","");
						Исключение
						КонецПопытки;
						
						Если ИмяОтчетаСистемное ="" Тогда
							Попытка
								ИмяОтчетаСистемное = ВариантОтчета.Отчет.Имя;	
								ИмяРеквизитаХраненияНастроек ="Настройки"; 
							Исключение
							КонецПопытки;
						КонецЕсли;
						
						Если ИмяОтчетаСистемное ="" Тогда
							
							ЗаполнятьСтруктуру = Ложь;
							СтркутраДанных.Вставить("Сообщение","Не отчет по имени, к чему привязан вариант");
							
						Иначе 
							СхемаОтчета = Отчеты[ИмяОтчетаСистемное].ПолучитьМакет(Метаданные.Отчеты[ИмяОтчетаСистемное].ОсновнаяСхемаКомпоновкиДанных);
							НастройкиКомпановки = ВариантОтчета[ИмяРеквизитаХраненияНастроек].Получить();	
						КонецЕсли;
						
						
						
					Иначе 
						ЗаполнятьСтруктуру = Ложь;
						СтркутраДанных.Вставить("Сообщение","Не найден вариант по имени");
					КонецЕсли;
					
				Иначе
					ЗаполнятьСтруктуру = Ложь;
					СтркутраДанных.Вставить("Сообщение","Нет метаданных ВариантыОтчетов");
				КонецЕсли;
				
				//Если НЕ ЗаполнятьСтруктуру Тогда
				//	ВыбркаНастроек = ХранилищеПользовательскихНастроекОтчетов.Выбрать(Новый Структура("Пользователь",ИмяПользователя()));
				//	НайденаНастройка = Ложь;
				//	Пока ВыбркаНастроек.Следующий() Цикл 
				//		
				//		Если ВыбркаНастроек.Представление = ИмяВариантОтчета Тогда
				//			ЗаполнятьСтруктуру = Истина;
				//			НастройкиКомпановки = ВыбркаНастроек.Настройки;
				//		КонецЕсли;
				//	КонецЦикла
				//КонецЕсли;
				
				ДанныеИнструкций = ПолучитьПошаговуюСтркутуру();
				
				ДанныеИнструкций.ТекущиеПеременные.Вставить("СхемаОтчета",СхемаОтчета);
				ДанныеИнструкций.ТекущиеПеременные.Вставить("ВариантОтчета",ВариантОтчета);
				ДанныеИнструкций.ТекущиеПеременные.Вставить("ТипОтчета","СКД");
				ДанныеИнструкций.ТекущиеПеременные.Вставить("НастройкиКомпановки",НастройкиКомпановки);
				
				ДанныеИнструкций.Вставить("ВыполняемоеДействие","СформироватьОтчет");
				
				Если ЗаполнятьСтруктуру = Истина Тогда
					
					ЗаполнитьТаблицуИнструкцийПоНастройкамСКД(ДанныеИнструкций);
					
					СтрокаПользователя.ТекДанныеУзла = ЗначениеВСтрокуВнутр(ДанныеИнструкций);
					
					СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций();
					
					ЗаголовокКоманды = СтркутраДанных.Заголовок;
				Иначе 
					//СообщениеОшибки
					
				КонецЕсли;
				
			КонецЕсли;
			
			
		ИначеЕсли ТекСтрокаДейстий.ТипДействия = "Выполнить код" Тогда
			
			СтркутраДанных =	ПолучитьРезультатВыполненияКода(ТекСтрокаДейстий.ДанныеФормирования,СтрокаПользователя.ПользовательИБ,ИмяФайла,ЗаголовокФайла);
			
			ОчиститьТекущийУровень();
			
		ИначеЕсли ТекСтрокаДейстий.ТипДействия = "Разрешить пользователя" Тогда
			
			Если ЗначениеЗаполнено(СтрокаПользователя.ТекДанныеУзла) Тогда
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций(ЗапросПользователя.text);
				
				
			Иначе 
				
				СтруктураОтборов = Новый Структура;
				СтруктураОтборов.Вставить("Подтвержден",Ложь);
				
				СтркутраДанныхПользователя = ПолучитьТекстСообщенияПользователей(СтруктураОтборов);
				
				ДанныеИнструкций = ПолучитьПошаговуюСтркутуру();
				
				ДанныеИнструкций.ТекущиеПеременные.Вставить("Пользователь");
				ДанныеИнструкций.Вставить("ВыполняемоеДействие","РазрешитьПользователя");
				
				СтрокаИнструкции = ДанныеИнструкций.ТаблицаИнструкций.Добавить();
				СтрокаИнструкции.ИмяПараметра 	= "Выбор пользователя";
				СтрокаИнструкции.Клавиатура 	= СтркутраДанныхПользователя.Клавиатура;
				СтрокаИнструкции.Сообщение		= СтркутраДанныхПользователя.Сообщение;
				СтрокаИнструкции.Заголовок		= "Выберите пользователя:";
				
				СтрокаПользователя.ТекДанныеУзла = ЗначениеВСтрокуВнутр(ДанныеИнструкций);
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций();
				
				ЗаголовокКоманды = СтркутраДанных.Заголовок;
				
			КонецЕсли;
			
		ИначеЕсли ТекСтрокаДейстий.ТипДействия = "Запретить пользователя" Тогда
			
			Если ЗначениеЗаполнено(СтрокаПользователя.ТекДанныеУзла) Тогда
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций(ЗапросПользователя.text);
				
			Иначе 
				
				СтруктураОтборов = Новый Структура;
				СтруктураОтборов.Вставить("Подтвержден",Истина);
				
				СтркутраДанныхПользователя = ПолучитьТекстСообщенияПользователей(СтруктураОтборов);
				
				ДанныеИнструкций = ПолучитьПошаговуюСтркутуру();
				
				ДанныеИнструкций.ТекущиеПеременные.Вставить("Пользователь");
				ДанныеИнструкций.Вставить("ВыполняемоеДействие","ЗапретитьПользователя");
				
				СтрокаИнструкции = ДанныеИнструкций.ТаблицаИнструкций.Добавить();
				СтрокаИнструкции.ИмяПараметра 	= "Выбор пользователя";
				СтрокаИнструкции.Клавиатура 	= СтркутраДанныхПользователя.Клавиатура;
				СтрокаИнструкции.Сообщение		= СтркутраДанныхПользователя.Сообщение;
				СтрокаИнструкции.Заголовок		= "Выберите пользователя:";
				
				СтрокаПользователя.ТекДанныеУзла = ЗначениеВСтрокуВнутр(ДанныеИнструкций);
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций();
				
				ЗаголовокКоманды = СтркутраДанных.Заголовок;
				
			КонецЕсли;
			
			
			
		ИначеЕсли ТекСтрокаДейстий.ТипДействия = "Список пользователей" Тогда
			
			СтркутраДанных = ПолучитьТекстСообщенияПользователей();
			
			ОчиститьТекущийУровень();
			
		ИначеЕсли ТекСтрокаДейстий.ТипДействия = "Добавить роль пользователю" Тогда
			
			Если ЗначениеЗаполнено(СтрокаПользователя.ТекДанныеУзла) Тогда
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций(ЗапросПользователя.text);
				
			Иначе 
				
				СтркутраДанныхПользователя = ПолучитьТекстСообщенияПользователей();
				
				ДанныеИнструкций = ПолучитьПошаговуюСтркутуру();
				
				ДанныеИнструкций.ТекущиеПеременные.Вставить("Пользователь");
				ДанныеИнструкций.ТекущиеПеременные.Вставить("Роль");
				ДанныеИнструкций.Вставить("ВыполняемоеДействие","ДобавитьРольПользователю");
				
				СтрокаИнструкции = ДанныеИнструкций.ТаблицаИнструкций.Добавить();
				СтрокаИнструкции.ИмяПараметра 	= "Выбор пользователя";
				СтрокаИнструкции.Клавиатура 	= СтркутраДанныхПользователя.Клавиатура;
				СтрокаИнструкции.Сообщение		= СтркутраДанныхПользователя.Сообщение;
				СтрокаИнструкции.Заголовок		= "Выберите пользователя:";
				
				СтрокаИнструкции = ДанныеИнструкций.ТаблицаИнструкций.Добавить();
				
				СтрокаИнструкции.ИмяПараметра 	= "Выбор роли";
				СтрокаИнструкции.Клавиатура 	= РольПользователей.Выгрузить().ВыгрузитьКолонку("Роль");
				СтрокаИнструкции.Сообщение 		= ПолучитьСписокРолейСтрокой();
				СтрокаИнструкции.Заголовок		= "Выберите роль:";
				
				СтрокаПользователя.ТекДанныеУзла = ЗначениеВСтрокуВнутр(ДанныеИнструкций);
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций();
				
				ЗаголовокКоманды = СтркутраДанных.Заголовок;
				
			КонецЕсли;
			
			
		ИначеЕсли ТекСтрокаДейстий.ТипДействия = "Удалить роль у пользователя" Тогда
			
			Если ЗначениеЗаполнено(СтрокаПользователя.ТекДанныеУзла) Тогда
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций(ЗапросПользователя.text);
				
			Иначе 
				
				СтркутраДанныхПользователя = ПолучитьТекстСообщенияПользователей();
				
				ДанныеИнструкций = ПолучитьПошаговуюСтркутуру();
				
				ДанныеИнструкций.ТекущиеПеременные.Вставить("Пользователь");
				ДанныеИнструкций.ТекущиеПеременные.Вставить("Роль");
				ДанныеИнструкций.Вставить("ВыполняемоеДействие","УдалитьРольУПользователя");
				
				СтрокаИнструкции = ДанныеИнструкций.ТаблицаИнструкций.Добавить();
				СтрокаИнструкции.ИмяПараметра 	= "Выбор пользователя";
				СтрокаИнструкции.Клавиатура 	= СтркутраДанныхПользователя.Клавиатура;
				СтрокаИнструкции.Сообщение		= СтркутраДанныхПользователя.Сообщение;
				СтрокаИнструкции.Заголовок		= "Выберите пользователя:";
				
				СтрокаИнструкции = ДанныеИнструкций.ТаблицаИнструкций.Добавить();
				
				СтрокаИнструкции.ИмяПараметра 	= "Выбор роли";
				СтрокаИнструкции.Клавиатура 	= РольПользователей.Выгрузить().ВыгрузитьКолонку("Роль");
				СтрокаИнструкции.Сообщение 		= ПолучитьСписокРолейСтрокой();
				СтрокаИнструкции.Заголовок		= "Выберите роль:";
				
				СтрокаПользователя.ТекДанныеУзла = ЗначениеВСтрокуВнутр(ДанныеИнструкций);
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций();
				
				ЗаголовокКоманды = СтркутраДанных.Заголовок;
				
			КонецЕсли;
			
			
			
		ИначеЕсли ТекСтрокаДейстий.ТипДействия = "Установить имя пользователя" Тогда
			
			Если ЗначениеЗаполнено(СтрокаПользователя.ТекДанныеУзла) Тогда
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций(ЗапросПользователя.text);
				
			Иначе 
				
				СтркутраДанныхПользователя = ПолучитьТекстСообщенияПользователей();
				
				ДанныеИнструкций = ПолучитьПошаговуюСтркутуру();
				
				ДанныеИнструкций.ТекущиеПеременные.Вставить("Пользователь");
				ДанныеИнструкций.ТекущиеПеременные.Вставить("ИмяПользователя");
				ДанныеИнструкций.Вставить("ВыполняемоеДействие","УстановитьИмяПользователя");
				
				СтрокаИнструкции = ДанныеИнструкций.ТаблицаИнструкций.Добавить();
				СтрокаИнструкции.ИмяПараметра 	= "Выбор пользователя";
				СтрокаИнструкции.Клавиатура 	= СтркутраДанныхПользователя.Клавиатура;
				СтрокаИнструкции.Сообщение		= СтркутраДанныхПользователя.Сообщение;
				СтрокаИнструкции.Заголовок		= "Выберите пользователя:";
				
				СтрокаИнструкции = ДанныеИнструкций.ТаблицаИнструкций.Добавить();
				СтрокаИнструкции.ИмяПараметра 	= "Выбор имени пользователя";
				СтрокаИнструкции.Клавиатура 	= Новый Массив;
				СтрокаИнструкции.Сообщение		= "";
				СтрокаИнструкции.Заголовок		= "Введите имя пользоватя базы:";
				
				
				СтрокаПользователя.ТекДанныеУзла = ЗначениеВСтрокуВнутр(ДанныеИнструкций);
				
				СтркутраДанных = ПолучитьСтруктуруДанныхПоТаблицеИнструкций();
				
				ЗаголовокКоманды = СтркутраДанных.Заголовок;
				
			КонецЕсли;
			
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтркутраДанных.Сообщение) Тогда
		ТекСообщение = СтркутраДанных.Сообщение; 
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтркутраДанных.Клавиатура) Тогда
		МассивКнопок =  СтркутраДанных.Клавиатура;
	КонецЕсли;
	
	Если  ТекСтрокаДейстий=Неопределено или НЕ ТекСтрокаДейстий.ТипДействия = "Выполнить код" Тогда
		
		СтркутраДанных.Свойство("ИмяФайла",ИмяФайла);
		СтркутраДанных.Свойство("ЗаголовокФайла",ЗаголовокФайла);
	
	КонецЕсли;	
	
	Если ЗначениеЗаполнено(ИмяФайла) Тогда
		
		//СтркутраДанных.Свойство("ЗаголовокФайла",ЗаголовокФайла);
		
	Иначе 
		
		
		ТекСообщение = ЗаголовокКоманды+?(ЗначениеЗаполнено(ЗаголовокКоманды),Символы.ПС,"")+ТекСообщение;
		
	КонецЕсли;
	
	ИтоговоеМеню.Вставить("МассивКнопок",МассивКнопок);
	
	ИтоговоеМеню.Вставить("text",ТекСообщение);
	ИтоговоеМеню.Вставить("ИмяФайла",ИмяФайла);
	ИтоговоеМеню.Вставить("ЗаголовокФайла",ЗаголовокФайла);
	
	Возврат ИтоговоеМеню;
	
КонецФункции

Процедура ЗаполнитьТаблицуИнструкцийПоНастройкамСКД(ДанныеИнструкций)
	
	НастройкиСКД= ДанныеИнструкций.ТекущиеПеременные.НастройкиКомпановки;
	
	Если Не ЗначениеЗаполнено(НастройкиСКД) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(НастройкиСКД) = Тип("НастройкиКомпоновкиДанных") Тогда
		
		Для Каждого стр из НастройкиСКД.ПараметрыДанных.Элементы Цикл 
			
			Если не стр.Использование тогда
				
				Продолжить;
				
			КонецЕсли;
			
			СтрокаИнструкции = ДанныеИнструкций.ТаблицаИнструкций.Добавить();
			СтрокаИнструкции.ИмяПараметра 	= Стр.Параметр;
			СтрокаИнструкции.Представление	= Стр.ПредставлениеПользовательскойНастройки;
			
			Если не ЗаполнитьСтрокуНастроекВИнструкцию(стр,СтрокаИнструкции) Тогда
				ДанныеИнструкций.ТаблицаИнструкций.Удалить(ДанныеИнструкций.ТаблицаИнструкций.Индекс(СтрокаИнструкции));
				
			Иначе 
				СтрокаИнструкции.ТипЗначения = ТипЗнч(стр.Значение);	
			КонецЕсли;
			
			
			
			
		КонецЦикла;
		
	ИначеЕсли  ТипЗнч(НастройкиСКД) = Тип("ПользовательскиеНастройкиКомпоновкиДанных") Тогда
		
		Если НастройкиСКД.ДополнительныеСвойства.Свойство("ДанныеОтчета") Тогда
			
			СтруктураДанныхОтчета = НастройкиСКД.ДополнительныеСвойства.ДанныеОтчета.Получить();
			
			Для Каждого стр из СтруктураДанныхОтчета Цикл 
				
				СтрокаИнструкции = ДанныеИнструкций.ТаблицаИнструкций.Добавить();
				СтрокаИнструкции.ИмяПараметра 	= Стр.Ключ;
				СтрокаИнструкции.Представление	= Стр.Ключ;
				
				Если не ЗаполнитьСтрокуНастроекВИнструкцию(стр,СтрокаИнструкции,"Ключ") Тогда
					ДанныеИнструкций.ТаблицаИнструкций.Удалить(ДанныеИнструкций.ТаблицаИнструкций.Индекс(СтрокаИнструкции));
				Иначе 
					СтрокаИнструкции.ТипЗначения = ТипЗнч(стр.Значение);
				КонецЕсли;
				
				
				
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	
КонецПроцедуры

Функция ЗаполнитьСтрокуНастроекВИнструкцию(стр,СтрокаИнструкции,ИмяЗначенияСтркутуры="")
	
	Если ИмяЗначенияСтркутуры="" Тогда
		ИмяЗначенияСтркутуры="Параметр";
	КонецЕсли;
	
	
	Если ТипЗнч(стр.Значение) 			= Тип("СтандартныйПериод") Тогда
		
		СтрокаИнструкции.Сообщение		= "Введите дату начала ("+стр[ИмяЗначенияСтркутуры]+"):";
		СтрокаИнструкции.Значение 		= Новый СтандартныйПериод;
		СтрокаИнструкции.Клавиатура 	= ТаблицаСтандартныхПериодов.ВыгрузитьКолонку("СинонимПериода");
		
	ИначеЕсли ТипЗнч(стр.Значение) 		= Тип("СтандартнаяДатаНачала") Тогда
		
		СтрокаИнструкции.Сообщение		= "Введите дату начала ("+стр[ИмяЗначенияСтркутуры]+"):";
		СтрокаИнструкции.Значение 		= Новый СтандартнаяДатаНачала;
		СтрокаИнструкции.Клавиатура 	= ТаблицаСтандартныхПериодов.ВыгрузитьКолонку("СинонимПериода");
		
	ИначеЕсли ТипЗнч(стр.Значение) 		= Тип("Булево") Тогда
		
		СтрокаИнструкции.Сообщение		= "Введите значение ("+стр[ИмяЗначенияСтркутуры]+"):";
		СтрокаИнструкции.Значение 		= Ложь;
		СтрокаИнструкции.Клавиатура 	= МассивДаНет;
		
	ИначеЕсли ТипЗнч(стр.Значение) 		= Тип("Дата") Тогда
		
		СтрокаИнструкции.Сообщение		= "Введите значение ("+стр[ИмяЗначенияСтркутуры]+"):";
		СтрокаИнструкции.Значение 		= Дата(0001,01,01);
		СтрокаИнструкции.Клавиатура 	= ТаблицаСтандартныхПериодов.ВыгрузитьКолонку("СинонимПериода");
		
	Иначе 
		
		СтрокаИнструкции.Значение	= стр.Значение;
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции


Функция ЗаполнитьМассивСтандартногоПериода()
	
	Если не ЗначениеЗаполнено(ТаблицаСтандартныхПериодов) Тогда
		
		ТаблицаСтандартныхПериодов = Новый ТаблицаЗначений;
		ТаблицаСтандартныхПериодов.Колонки.Добавить("СинонимПериода");
		ТаблицаСтандартныхПериодов.Колонки.Добавить("ЗначениеПериода");
		
		Нов = ТаблицаСтандартныхПериодов.Добавить();
		Нов.СинонимПериода 	="Сегодня";
		Нов.ЗначениеПериода = КонецДня(ТекущаяДата());
		
		Нов = ТаблицаСтандартныхПериодов.Добавить();
		Нов.СинонимПериода 	="Вчера";
		Нов.ЗначениеПериода = НачалоДня(НачалоДня(ТекущаяДата())-1);
		
		Нов = ТаблицаСтандартныхПериодов.Добавить();
		Нов.СинонимПериода 	="7 д. назад";
		Нов.ЗначениеПериода = НачалоДня(НачалоДня(ТекущаяДата())-60*60*24*7);
		
		Нов = ТаблицаСтандартныхПериодов.Добавить();
		Нов.СинонимПериода 	="7 д. вперед";
		Нов.ЗначениеПериода = КонецДня(НачалоДня(ТекущаяДата())+60*60*24*7);
		
		Нов = ТаблицаСтандартныхПериодов.Добавить();
		Нов.СинонимПериода 	="Начало месяца";
		Нов.ЗначениеПериода = НачалоМесяца(ТекущаяДата());
		
		Нов = ТаблицаСтандартныхПериодов.Добавить();
		Нов.СинонимПериода 	="Конец месяца";
		Нов.ЗначениеПериода = КонецМесяца(ТекущаяДата());
				
	КонецЕсли;
	
	Возврат ТаблицаСтандартныхПериодов;
	
КонецФункции

Функция ПолучитьСтруктуруДанныхПоТаблицеИнструкций(Знач ЗначениеВыбора=Неопределено)
	
	ДанныеИнструкций = ЗначениеИзСтрокиВнутр(СтрокаПользователя.ТекДанныеУзла);
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Сообщение","");
	СтруктураВозврата.Вставить("Заголовок","");
	СтруктураВозврата.Вставить("Клавиатура",Новый Массив);
	
	ИтоговыйЗаголовок ="";
	ВсеИнструкцииВыполнены = Истина;
	для Каждого стр из ДанныеИнструкций.ТаблицаИнструкций Цикл 
		
		ТекЗаголовок = стр.Заголовок;
		Если не ЗначениеЗаполнено(ТекЗаголовок) Тогда
			ТекЗаголовок = стр.Представление;
		КонецЕсли;
		Если не ЗначениеЗаполнено(ТекЗаголовок) Тогда
			ТекЗаголовок = стр.ИмяПараметра;
		КонецЕсли;
		
		ИтоговыйЗаголовок = ИтоговыйЗаголовок+ТекЗаголовок;//+" "+ СокрЛП(стр.Значение);
		Если стр.Выполнен Тогда 
			Продолжить;
		ИначеЕсли ЗначениеЗаполнено(ЗначениеВыбора) Тогда 
			
			ИнстуркцияВыполнена= Истина;
			Если стр.ИмяПараметра 		="Выбор пользователя" Тогда
				ИнстуркцияВыполнена 	= ВыполнитьИнструкцию_ВыборПользователя(ЗначениеВыбора,Стр,ДанныеИнструкций)
			ИначеЕсли  стр.ИмяПараметра ="Выбор роли" Тогда 
				ИнстуркцияВыполнена 	= ВыполнитьИнструкцию_ВыборРоли(ЗначениеВыбора,стр,ДанныеИнструкций);
			ИначеЕсли  стр.ИмяПараметра ="Выбор имени пользователя" Тогда 
				ИнстуркцияВыполнена 	= ВыполнитьИнструкцию_ВводИмениПользователя(ЗначениеВыбора,стр,ДанныеИнструкций);
			ИначеЕсли стр.ТипЗначения 	= Тип("СтандартныйПериод") Тогда
				
				Если НЕ ЗначениеЗаполнено(стр.Значение.ДатаНачала) Тогда
					
					ВыполненВвод = ВыполнитьИнструкцию_ВводДаты(ЗначениеВыбора,стр,ДанныеИнструкций);
					
					Если ВыполненВвод Тогда
						стр.Значение.ДатаНачала = НачалоДня(ЗначениеВыбора); 
						стр.Сообщение 			= "Введите дату окончания";
					КонецЕсли;
					
				ИначеЕсли НЕ ЗначениеЗаполнено(стр.Значение.ДатаОкончания) Тогда
					
					ВыполненВвод = ВыполнитьИнструкцию_ВводДаты(ЗначениеВыбора,стр,ДанныеИнструкций);
					
					Если ВыполненВвод Тогда
						стр.Значение.ДатаОкончания = КонецДня(ЗначениеВыбора); 
					КонецЕсли;
					
				КонецЕсли;
				ЗначениеВыбора = Неопределено;
				Если ЗначениеЗаполнено(стр.Значение.ДатаНачала) И ЗначениеЗаполнено(стр.Значение.ДатаОкончания) Тогда
					стр.Выполнен = Истина;
					ИнстуркцияВыполнена= Истина;
				КонецЕсли;
				
			ИначеЕсли стр.ТипЗначения 	= Тип("СтандартнаяДатаНачала") Тогда
				
				ВыполненВвод = ВыполнитьИнструкцию_ВводДаты(ЗначениеВыбора,стр,ДанныеИнструкций);
				
				Если ВыполненВвод Тогда
					стр.Значение.ДатаНачала = КонецДня(ЗначениеВыбора); 
					
				КонецЕсли;
				
				ЗначениеВыбора = Неопределено;
				Если ЗначениеЗаполнено(стр.Значение.Дата)Тогда
					стр.Выполнен = Истина;
					ИнстуркцияВыполнена= Истина;
				КонецЕсли;
				
			ИначеЕсли стр.ТипЗначения 	= Тип("Булево") Тогда
				
				ВыполненВвод = ВыполнитьИнструкцию_ВводБулево(ЗначениеВыбора,стр,ДанныеИнструкций);
				
				Если ВыполненВвод Тогда
					
					стр.Значение = ЗначениеВыбора; 
					стр.Выполнен = Истина;
					ИнстуркцияВыполнена= Истина;
					
				КонецЕсли;
				
				ЗначениеВыбора = Неопределено;
				
			ИначеЕсли стр.ТипЗначения 	= Тип("Дата") Тогда
				
				ВыполненВвод = ВыполнитьИнструкцию_ВводДаты(ЗначениеВыбора,стр,ДанныеИнструкций);
				
				Если ВыполненВвод Тогда
					
					стр.Значение = ЗначениеВыбора; 
					стр.Выполнен = Истина;
					ИнстуркцияВыполнена= Истина;
					
				КонецЕсли;
				
				ЗначениеВыбора = Неопределено;
				
				
			КонецЕсли;
			
			
			Если НЕ ИнстуркцияВыполнена Тогда
				ВсеИнструкцииВыполнены = Ложь;
				ОчиститьТекущийУровень();
				Прервать;
			КонецЕсли;
			
		КонецЕсли;
		
		Если НЕ стр.Выполнен Тогда
			
			ВсеИнструкцииВыполнены = Ложь;
			
			СтруктураВозврата.Вставить("Сообщение",стр.Сообщение);
			СтруктураВозврата.Вставить("Заголовок",ИтоговыйЗаголовок);
			СтруктураВозврата.Вставить("Клавиатура",?(ЗначениеЗаполнено(стр.Клавиатура),стр.Клавиатура,Новый Массив));
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	
	
	Если ВсеИнструкцииВыполнены Тогда
		ДанныеИнструкций.ОбработкаЗавершена=Истина;
	КонецЕсли;

	
	Если ДанныеИнструкций.ОбработкаЗавершена Тогда
		
		ВыполнитьИтоговуюИнструкцию(ДанныеИнструкций,СтруктураВозврата);
		
		ОчиститьТекущийУровень();
		
		
	Иначе 
		
		СтрокаПользователя.ТекДанныеУзла = ЗначениеВСтрокуВнутр(ДанныеИнструкций);
		
	КонецЕсли;
	
	Возврат СтруктураВозврата;
	
КонецФункции


Процедура ВыполнитьИтоговуюИнструкцию(ДанныеИнструкций,СтруктураВозврата)
	
	Если ДанныеИнструкций.ВыполняемоеДействие = "РазрешитьПользователя" Тогда
		
		УстановитьАктивностьПользователю(Истина,ДанныеИнструкций,СтруктураВозврата);
		
	ИначеЕсли  ДанныеИнструкций.ВыполняемоеДействие ="ЗапретитьПользователя" Тогда
		
		УстановитьАктивностьПользователю(Ложь,ДанныеИнструкций,СтруктураВозврата);
		
	ИначеЕсли  ДанныеИнструкций.ВыполняемоеДействие ="ДобавитьРольПользователю" Тогда
		
		ИзменитьРольПользователя(Истина,ДанныеИнструкций,СтруктураВозврата);
		
	ИначеЕсли  ДанныеИнструкций.ВыполняемоеДействие ="УдалитьРольУПользователя" Тогда
		
		ИзменитьРольПользователя(Ложь,ДанныеИнструкций,СтруктураВозврата);
		
	ИначеЕсли ДанныеИнструкций.ВыполняемоеДействие = "УстановитьИмяПользователя" Тогда
		
		УстановитьИмяПользователя(ДанныеИнструкций,СтруктураВозврата);
		
	ИначеЕсли ДанныеИнструкций.ВыполняемоеДействие = "СформироватьОтчет" Тогда
		
		СформироватьОтчет(ДанныеИнструкций,СтруктураВозврата);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура СформироватьОтчет(ДанныеИнструкций,СтруктураВозврата)
	
	Попытка
		ТабДокРезультат = ПолучитьРезультатФормированитьяОтчетаСКД(ДанныеИнструкций);
	Исключение
		Сообщить(ОписаниеОшибки());
		ТабДокРезультат = Новый ТабличныйДокумент;
	КонецПопытки;
	
	Если не ЗначениеЗаполнено(ТипФайлаОтчета) Тогда
		ТипФайлаОтчета = "HTML5";
	КонецЕсли;
	
		
	ТипТабДок = ТипФайлаТабличногоДокумента[ТипФайлаОтчета];
	
	ВремФайл = ПолучитьИмяВременногоФайла(ПолучитьРасширениеФайлаПотипуТабДок());
	
	ТабДокРезультат.Записать(ВремФайл,ТипТабДок);
	
	СтруктураВозврата.Вставить("ЗаголовокФайла",СокрЛП(ДанныеИнструкций.ТекущиеПеременные.ВариантОтчета));
	СтруктураВозврата.Вставить("ИмяФайла",ВремФайл);

	//ТекСообщение = ВремФайл;
	
КонецПроцедуры

Функция ПолучитьРасширениеФайлаПотипуТабДок()
	
	Если ВРег(ТипФайлаОтчета)= "ANSITXT" или  ВРег(ТипФайлаОтчета)= "TXT" Тогда
		Возврат "txt";
	ИначеЕсли ВРег(ТипФайлаОтчета) = "DOCX" Тогда
		Возврат "docx";
	ИначеЕсли ВРег(ТипФайлаОтчета) = "HTML" или ВРег(ТипФайлаОтчета) = "HTML3" или ВРег(ТипФайлаОтчета) = "HTML4" или ВРег(ТипФайлаОтчета) = "HTML5" Тогда
		Возврат "html";
	ИначеЕсли ВРег(ТипФайлаОтчета) = "DOCX" Тогда
		Возврат "docx";
	ИначеЕсли ВРег(ТипФайлаОтчета) = "MXL7" ИЛИ ВРег(ТипФайлаОтчета) = "MXL" Тогда
		Возврат "mxl";
	ИначеЕсли ВРег(ТипФайлаОтчета) = "ODS" Тогда
		Возврат "ods";
	ИначеЕсли ВРег(ТипФайлаОтчета) = "PDF" Тогда
		Возврат "pdf";
	ИначеЕсли ВРег(ТипФайлаОтчета) = "XLS" ИЛИ ВРег(ТипФайлаОтчета) = "XLS95"  ИЛИ ВРег(ТипФайлаОтчета) = "XLS95" Тогда
		Возврат "xls";
	ИначеЕсли ВРег(ТипФайлаОтчета) = "XLSX" Тогда
		Возврат "xls";                      
	КонецЕсли;
	
КонецФункции


Процедура УстановитьИмяПользователя(ДанныеИнструкций,СтруктураВозврата)
	
	ПоискПользователя = ЭтотОбъект.Пользователи.Найти(ДанныеИнструкций.ТекущиеПеременные.Пользователь,"ИДПользователя");
	
	ТекСообщение = "";
	Если ПоискПользователя = Неопределено Тогда
		
		ТекСообщение = ТекСообщение+" Не удалось найти пользователя ";
		
	Иначе 
		
		ПоискПользователя.ПользовательИБ = ДанныеИнструкций.ТекущиеПеременные.ИмяПользователя;
			
		ТекСообщение = ТекСообщение+"Имя пользователя установлено";
		
		
	КонецЕсли;
	
	СтруктураВозврата.Сообщение =ТекСообщение;
	
КонецПроцедуры

Процедура УстановитьАктивностьПользователю(ЗначениеАктивности,ДанныеИнструкций,СтруктураВозврата)
	
	Если ЗначениеАктивности Тогда
		Генератор = Новый ГенераторСлучайныхЧисел();
		
		
		Если НеТребоватьПодтвежденияПИН Тогда
			ПИнКОд = "";
			СообщениеУспешности = " Доступ разрешен";
		Иначе 
			ПИнКОд = Формат(Генератор.СлучайноеЧисло(1000,9999),"ЧГ=0");
			СообщениеУспешности = " Доступ разрешен, ПИН код "+ПИнКОд;
		КонецЕсли;
		
	Иначе 
		
		СообщениеУспешности = " Доступ запрещен ";
		ПИнКОд = 0;
		
	КонецЕсли;
	
	ПоискПользователя = ЭтотОбъект.Пользователи.Найти(ДанныеИнструкций.ТекущиеПеременные.Пользователь,"ИДПользователя");
	
	ТекСообщение = "";
	Если ПоискПользователя = Неопределено Тогда
		
		ТекСообщение = ТекСообщение+" Не удалось найти пользователя ";
		
	Иначе 
		
		Если ЗначениеАктивности тогда
			
			ПоискПользователя.Подтвержден = НеТребоватьПодтвежденияПИН;
		Иначе 
			ПоискПользователя.Подтвержден = Ложь;
		КонецЕсли;
		ТекСообщение = ТекСообщение+СообщениеУспешности;
		ПоискПользователя.КодПодтверждения = ПИнКОд;
		
	КонецЕсли;
	
	СтруктураВозврата.Сообщение =ТекСообщение;
	
КонецПроцедуры

Процедура ИзменитьРольПользователя(УстановитьРоль,ДанныеИнструкций,СтруктураВозврата)
	
	ПоискПользователя = ЭтотОбъект.Пользователи.Найти(ДанныеИнструкций.ТекущиеПеременные.Пользователь,"ИДПользователя");
	
	ТекСообщение = "";
	Если ПоискПользователя = Неопределено Тогда
		
		ТекСообщение = ТекСообщение+" Не удалось найти пользователя ";
		
	Иначе 
		
		Если УстановитьРоль Тогда
			
			Если Найти(ПоискПользователя.Роли,СокрЛП(ДанныеИнструкций.ТекущиеПеременные.Роль))>0 Тогда
				ТекСообщение = ТекСообщение+" Такая роль уже установлена ";
			Иначе
				Разделитель = ?(ЗначениеЗаполнено(ПоискПользователя.Роли)," | ","");
				ПоискПользователя.Роли = ПоискПользователя.Роли+ Разделитель+СокрЛП(ДанныеИнструкций.ТекущиеПеременные.Роль);				 
				ТекСообщение = ТекСообщение+" Роль установлена! ";
			КонецЕсли;
			
		Иначе 
			
			Если Найти(ПоискПользователя.Роли,СокрЛП(ДанныеИнструкций.ТекущиеПеременные.Роль))=0 Тогда
				ТекСообщение = ТекСообщение+" Роли у пользоватея нет. ";
			Иначе
				ПоискПользователя.Роли = СокрЛП(СтрЗаменить(ПоискПользователя.Роли,СокрЛП(ДанныеИнструкций.ТекущиеПеременные.Роль),""));
				ПоискПользователя.Роли = СокрЛП(СтрЗаменить(ПоискПользователя.Роли,"| |","|"));
				ПоискПользователя.Роли = СокрЛП(СтрЗаменить(ПоискПользователя.Роли,"  "," "));
				ПоискПользователя.Роли = СокрЛП(СтрЗаменить(ПоискПользователя.Роли,"|  ","| "));
				ПоискПользователя.Роли = СокрЛП(СтрЗаменить(ПоискПользователя.Роли,"  |"," |"));
				ПоискПользователя.Роли = СокрЛП(СтрЗаменить(ПоискПользователя.Роли,"| |","|"));
				ПоискПользователя.Роли = СокрЛП(СтрЗаменить(ПоискПользователя.Роли,"||","|"));
				
				
				Если Прав(ПоискПользователя.Роли,1) = "|" Тогда
					ПоискПользователя.Роли = СокрЛП(Прав(ПоискПользователя.Роли,СтрДлина(ПоискПользователя.Роли)-1));
				КонецЕсли;
				Если Лев(ПоискПользователя.Роли,1) = "|" Тогда
					ПоискПользователя.Роли = СокрЛП(Сред(ПоискПользователя.Роли,2));
				КонецЕсли;
				
				ТекСообщение = ТекСообщение+" Роль удалена! ";
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	СтруктураВозврата.Сообщение =ТекСообщение;

	
КонецПроцедуры

Функция ВыполнитьИнструкцию_ВводДаты(ЗначениеВыбора,СтрИнструкции,ДанныеИнструкций)
		
	Если Не ЗначениеЗаполнено(ЗначениеВыбора) Тогда
		СтрИнструкции.Сообщение ="Необходимо ввести дату";
		Возврат Ложь;				
	КонецЕсли;
	
	Попытка
		ЗначениеВыбора = Дата(ЗначениеВыбора);
		Возврат Истина;
	Исключение
		
	КонецПопытки;
	
	ПопыткаПреобразование = ПолучитьДатуИзСтроки(ЗначениеВыбора);
	Если ТипЗнч(ПопыткаПреобразование)=Тип("Дата") и ЗначениеЗаполнено(ПопыткаПреобразование) Тогда
		ЗначениеВыбора = ПопыткаПреобразование;
		Возврат Истина;
	КонецЕсли;
		
	
	ПоискСтандартного = ТаблицаСтандартныхПериодов.Найти(ЗначениеВыбора);
	
	Если НЕ ПоискСтандартного = Неопределено Тогда
		 ЗначениеВыбора =  ПоискСтандартного.ЗначениеПериода;
		 Возврат Истина;
	КонецЕсли;
	
		
	Возврат Ложь;
КонецФункции

Функция ВыполнитьИнструкцию_ВводБулево(ЗначениеВыбора,СтрИнструкции,ДанныеИнструкций)
		
	Если Не ЗначениеЗаполнено(ЗначениеВыбора) Тогда
		СтрИнструкции.Сообщение ="Необходимо ввести булево";
		Возврат Ложь;				
	КонецЕсли;
	
	Попытка
		ЗначениеВыбора = Булево(ЗначениеВыбора);
		Возврат Истина;
	Исключение
		
	КонецПопытки;
	
	Если НРег(ЗначениеВыбора) = "да" Тогда
		ЗначениеВыбора = Истина;
		Возврат Истина;
	КонецЕсли;
	
	Если НРег(ЗначениеВыбора) = "нет" Тогда
		ЗначениеВыбора = Ложь;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции


Функция ВыполнитьИнструкцию_ВыборПользователя(ЗначениеВыбора,СтрИнструкции,ДанныеИнструкций)
	
	ИДПользователя =СтрЗаменить(ЗначениеВыбора,"/","");
	Попытка
		
		ИДПользователя = Число(ИДПользователя);
		
	Исключение
		СтрИнструкции.Сообщение ="Не верный ИД пользователя";
		
		Возврат Ложь;
		
	КонецПопытки;
	
	ПоискПользователя = ЭтотОбъект.Пользователи.Найти(ИДПользователя,"ИДПользователя");
	
	Если ПоискПользователя = Неопределено Тогда
		СтрИнструкции.Сообщение ="Нет такого пользователя по ИД";
		Возврат Ложь;
	КонецЕсли;
	
	СтрИнструкции.Значение = ПоискПользователя.ИДПользователя;
	ДанныеИнструкций.ТекущиеПеременные.Вставить("Пользователь",ПоискПользователя.ИДПользователя);
	
	СтрИнструкции.Выполнен = Истина;
	ЗначениеВыбора = Неопределено;
	
	Возврат Истина;
КонецФункции

Функция ВыполнитьИнструкцию_ВыборРоли(ЗначениеВыбора,СтрИнструкции,ДанныеИнструкций)
	
	ИмяРоли =СтрЗаменить(ЗначениеВыбора,"/","");
	ПоискРоли = ЭтотОбъект.РольПользователей.Найти(ИмяРоли,"Роль");
	Если ПоискРоли = Неопределено Тогда
		СтрИнструкции.Сообщение ="Нет такой роли";
		Возврат Ложь;				
		
	ИначеЕсли не ЗначениеЗаполнено(ДанныеИнструкций.ТекущиеПеременные.Пользователь) Тогда
		
		
		СтрИнструкции.Сообщение ="Что то пошло не так. ИД пользователя пустой";
		Возврат Ложь;		
	КонецЕсли;
	
	СтрИнструкции.Значение = ПоискРоли.Роль ;
	ДанныеИнструкций.ТекущиеПеременные.Вставить("Роль",ПоискРоли.Роль);
	
	ЗначениеВыбора = Неопределено;
	СтрИнструкции.Выполнен = Истина;
	
	Возврат Истина;
КонецФункции

Функция ВыполнитьИнструкцию_ВводИмениПользователя(ЗначениеВыбора,СтрИнструкции,ДанныеИнструкций)
	
	ЗначениеВыбора =СтрЗаменить(ЗначениеВыбора,"/","");
	
	Если Не ЗначениеЗаполнено(ЗначениеВыбора) Тогда
		
		СтрИнструкции.Сообщение ="Необходимо ввести имя";
		Возврат Ложь;				
	КонецЕсли;
	
	СтрИнструкции.Значение = ЗначениеВыбора ;
	ДанныеИнструкций.ТекущиеПеременные.Вставить("ИмяПользователя",ЗначениеВыбора);
	
	ЗначениеВыбора = Неопределено;
	СтрИнструкции.Выполнен = Истина;
	
	Возврат Истина;
КонецФункции




Процедура  ОчиститьТекущийУровень()
	
	СтрокаПользователя.ТекущийУзел = "";
	СтрокаПользователя.ТекДанныеУзла = "";
	
КонецПроцедуры


Функция ПолучитьПошаговуюСтркутуру()
	
	СтркутураВозврата = Новый Структура;
	СтркутураВозврата.Вставить("ТекущиеПеременные",Новый Структура);
	СтркутураВозврата.Вставить("ОбработкаЗавершена",Ложь);
	СтркутураВозврата.Вставить("ВыполняемоеДействие","");
	//СтркутураВозврата.Вставить("СообщениеОшибки","");
	
	ТаблицаДанных = Новый ТаблицаЗначений;
	ТаблицаДанных.Колонки.Добавить("Выполнен",Новый ОписаниеТипов("Булево"));
	ТаблицаДанных.Колонки.Добавить("ИмяПараметра",Новый ОписаниеТипов("Строка"));
	ТаблицаДанных.Колонки.Добавить("Представление",Новый ОписаниеТипов("Строка"));
	ТаблицаДанных.Колонки.Добавить("Заголовок",Новый ОписаниеТипов("Строка"));
	ТаблицаДанных.Колонки.Добавить("Значение");
	ТаблицаДанных.Колонки.Добавить("Клавиатура");
	ТаблицаДанных.Колонки.Добавить("Сообщение");
	ТаблицаДанных.Колонки.Добавить("ТипЗначения");
	
	СтркутураВозврата.Вставить("ТаблицаИнструкций",ТаблицаДанных);

	Возврат СтркутураВозврата;
	
КонецФункции

Функция ПолучитьСписокРолейСтрокой()
	
	Итог = "";	
	
	Для Каждого стр из РольПользователей Цикл 
		Итог = Итог+СокрЛП(стр.Роль)+Символы.ПС;
	КонецЦикла;
	
	Возврат Лев(Итог,СтрДлина(Итог)-1);
	
КонецФункции

Функция ПолучитьРезультатФормированитьяОтчетаСКД(ДанныеИнструкций)
	
	СхемаОтчета = ДанныеИнструкций.ТекущиеПеременные.СхемаОтчета; 
	НастройкиВарианта = ДанныеИнструкций.ТекущиеПеременные.НастройкиКомпановки;
	
	Если СхемаОтчета = Неопределено Тогда
		
		Если ТипЗнч(НастройкиВарианта) = Тип("ПользовательскиеНастройкиКомпоновкиДанных") Тогда
			
		Иначе 
			Возврат Новый ТабличныйДокумент;
		КонецЕсли;
	КонецЕсли;
	
	
	ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаОтчета);
	
	КомпоновщикНастрокеПолей = Новый КомпоновщикНастроекКомпоновкиДанных;
	Если НастройкиВарианта = Неопределено Тогда
		НастройкиВарианта = СхемаОтчета.НастройкиПоУмолчанию;
	КонецЕсли;
	
	КомпоновщикНастрокеПолей.ЗагрузитьНастройки(НастройкиВарианта);
	
	КомпоновщикНастрокеПолей.Инициализировать(ИсточникНастроек);
	
	ЗаполнитьНастройкиПоВведенным(КомпоновщикНастрокеПолей,ДанныеИнструкций.ТаблицаИнструкций);

	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаОтчета, КомпоновщикНастрокеПолей.ПолучитьНастройки());
	
	////Создадим и инициализируем процессор компоновки
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки, , , Истина);
	
	//Создадим и инициализируем процессор вывода результата
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	//ПроцессорВывода.УстановитьОбъект(ДеревоГруппировок);
	табДокРезультат = Новый ТабличныйДокумент;
	ПроцессорВывода.УстановитьДокумент(табДокРезультат);
	ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	
	Возврат табДокРезультат;
	
КонецФункции

Процедура ЗаполнитьНастройкиПоВведенным(КомпоновщикНастрокеПолей,ТаблицаИнструкций)
	
	для Каждого стр из ТаблицаИнструкций Цикл 
		
		КомпоновщикНастрокеПолей.Настройки.ПараметрыДанных.УстановитьЗначениеПараметра(стр.ИмяПараметра,Стр.Значение);
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьРезультатВыполненияКода(ТекстКода,ПользовательПереданный,ПутьКФайлу="",ИмяФайла="") Экспорт 
	
	перем Результат; 
	перем ПользовательИБ; 
	
	СтруктураВозврата = Новый Структура;
	
	ПользовательИБ = ПользовательПереданный;
	
	Результат = "";
	Клаиватура = Новый Массив;
	Попытка
		
		Выполнить(ТекстКода);
		
	Исключение
		
		Результат = ОписаниеОшибки();
		
	КонецПопытки;
	
	СтруктураВозврата.Вставить("Сообщение",Результат);
	СтруктураВозврата.Вставить("Клавиатура",Клаиватура);
	
	Возврат СтруктураВозврата;
КонецФункции

Функция ПолучитьТекстСообщенияПользователей(Знач СтрктураОтборов=Неопределено)
	
	Если СтрктураОтборов = Неопределено Тогда
		ПоискСтрок = ЭтотОбъект.Пользователи;
	Иначе 
		ПоискСтрок = ЭтотОбъект.Пользователи.НайтиСтроки(СтрктураОтборов);
	КонецЕсли;
	
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Сообщение","");
	СтруктураВозврата.Вставить("Клавиатура",Новый Массив);
	ИтоговоеСообщение = "";
	
	
	
	для Каждого стр из ПоискСтрок Цикл 
		
		Разделитель = ?(ЗначениеЗаполнено(ИтоговоеСообщение),Символы.ПС,"");
		
		ТекПользователь = "/"+Формат(стр.ИДПользователя,"ЧГ=0")
		+" "+стр.Имя
		+?(ЗначениеЗаполнено(стр.Фамилия)," - "+СокрЛП(стр.Фамилия),"")
		+?(ЗначениеЗаполнено(стр.ЮзерНайм)," - @"+СокрЛП(стр.ЮзерНайм),"")
		+?(стр.Подтвержден," / (Активен)"," / (Отключен)")
		+?(ЗначениеЗаполнено(стр.Роли)," / "+СокрЛП(стр.Роли),"")
		+?(ЗначениеЗаполнено(стр.ПользовательИБ)," / "+СокрЛП(стр.ПользовательИБ),"");
		
		ИтоговоеСообщение = ИтоговоеСообщение+Разделитель+ТекПользователь;
		
	КонецЦикла;
	
	СтруктураВозврата.Вставить("Сообщение",ИтоговоеСообщение);
	
	Возврат СтруктураВозврата;
КонецФункции

Функция ПолучитьСтрокуПользователя(ЗапросПользователя)
	
	Набор = РегистрыСведений.ТелеграмПользователи.СоздатьНаборЗаписей();
	Набор.Отбор.ИДПользователя.Установить(ЗапросПользователя.ID);
	Набор.Прочитать();
	
	Если Набор.Количество() Тогда
		ПоискПользователя = Набор[0];
	Иначе
		ПоискПользователя 					= Набор.Добавить();
		ПоискПользователя.ИДПользователя 	= ЗапросПользователя.ID;
		ПоискПользователя.Подтвержден 		= НеТребоватьПодтвежденияПИН;
		//ПоискПользователя.Роли 				= РолиПоУмолчанию;
		//ПоискПользователя.ПользовательИБ 	= ПользовательПоУмолчанию;
		ПоискПользователя.ДатаСоздания		= ТекущаяДата();
		
		ГСЧ = Новый ГенераторСлучайныхЧисел;
		ПоискПользователя.КодПодтверждения 	= Формат(ГСЧ.СлучайноеЧисло(100000, 999999), "ЧГ=0");
		
		ПоискПользователя.ФизЛицо = НайтиФизЛицоЗаВходящимиДанными(ЗапросПользователя);
	КонецЕсли;
	
	ПоискПользователя.КоличествоЗапросов 	= ПоискПользователя.КоличествоЗапросов+1;
	ПоискПользователя.Имя 					= ЗапросПользователя.first_name;
	ПоискПользователя.Фамилия 				= ЗапросПользователя.last_name;
	ПоискПользователя.ЮзерНайм 				= ЗапросПользователя.ЮзерНайм;
	
	Набор.Записать(Истина);
	
	Возврат ПоискПользователя;
	
КонецФункции

Функция НайтиФизЛицоЗаВходящимиДанными(ЗапросПользователя)
	ФизЛицо = Неопределено;
	
	МассивВариантов = Новый Массив;
	МассивВариантов.Добавить(ЗапросПользователя.first_name + " " + ЗапросПользователя.last_name);
	МассивВариантов.Добавить(ЗапросПользователя.last_name + " " + ЗапросПользователя.first_name);
	МассивВариантов.Добавить(ЗапросПользователя.first_name + ЗапросПользователя.last_name);
	МассивВариантов.Добавить(ЗапросПользователя.last_name + ЗапросПользователя.first_name);
	
	МассивВариантов.Добавить(ТРег(ЗапросПользователя.first_name) + " " + ТРег(ЗапросПользователя.last_name));
	МассивВариантов.Добавить(ТРег(ЗапросПользователя.last_name) + " " + ТРег(ЗапросПользователя.first_name));
	МассивВариантов.Добавить(ТРег(ЗапросПользователя.first_name) + ТРег(ЗапросПользователя.last_name));
	МассивВариантов.Добавить(ТРег(ЗапросПользователя.last_name) + ТРег(ЗапросПользователя.first_name));

	МассивВариантов.Добавить(ЗапросПользователя.ЮзерНайм);
	МассивВариантов.Добавить(ТРег(ЗапросПользователя.ЮзерНайм));
	
	Для Каждого Вариант из МассивВариантов Цикл
		Если Вариант = "" Тогда
			Продолжить;
		КонецЕсли;
		
		ФизЛицо = Справочники.ФизическиеЛица.НайтиПоНаименованию(Вариант);
		
		Если ЗначениеЗаполнено(ФизЛицо) Тогда
			Возврат ФизЛицо;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ФизЛицо;
	
КонецФункции

Процедура ИзменитьДанныеПользователя(СтруктураПользователя, Реквизит, Значение)
	Набор = РегистрыСведений.ТелеграмПользователи.СоздатьНаборЗаписей();
	Набор.Отбор.ИДПользователя.Установить(СтруктураПользователя.ИДПользователя);
	Набор.Прочитать();
	
	Если Набор.Количество() Тогда
		ПоискПользователя = Набор[0];
		ПоискПользователя[Реквизит] = Значение;
	КонецЕсли;
	
	Набор.Записать(Истина);

КонецПроцедуры

Процедура ИзменитьДанныеЗапроса(СтруктураЗапроса, Реквизит, Значение)
	Набор = РегистрыСведений.ТелеграмЗапросы.СоздатьНаборЗаписей();
	Набор.Отбор.update_id.Установить(СтруктураЗапроса.update_id);
	Набор.Отбор.message_id.Установить(СтруктураЗапроса.message_id);
	Набор.Отбор.date.Установить(СтруктураЗапроса.date);
	Набор.Прочитать();
	
	Если Набор.Количество() Тогда
		ПоискЗапроса = Набор[0];
		ПоискЗапроса[Реквизит] = Значение;
	КонецЕсли;
	
	Набор.Записать(Истина);
КонецПроцедуры

Процедура УдалитьДанныеЗапроса(СтруктураЗапроса)
	Набор = РегистрыСведений.ТелеграмЗапросы.СоздатьНаборЗаписей();
	Набор.Отбор.update_id.Установить(СтруктураЗапроса.update_id);
	Набор.Отбор.message_id.Установить(СтруктураЗапроса.message_id);
	Набор.Отбор.date.Установить(СтруктураЗапроса.date);
	Набор.Записать();
КонецПроцедуры

Процедура ИзменитьДанныеЗадачиНаПодтверждение(Задача, Реквизит, Значение)
	Набор = РегистрыСведений.ТелеграмЗадачиПодтверждения.СоздатьНаборЗаписей();
	Набор.Отбор.ОбъектПодтверждения.Установить(Задача);
	Набор.Прочитать();
	
	Если Набор.Количество() Тогда
		ПоискЗадачи = Набор[0];
		ПоискЗадачи[Реквизит] = Значение;
	КонецЕсли;
	
	Набор.Записать(Истина);

КонецПроцедуры

Процедура ОтправитьСообщение (СтруктураСообщения,ok,ИмяФайлаОтправки="",ЗаголовокФайла="", ОтветСоотв = Неопределено) Экспорт
	
	Сервер = "api.telegram.org";
	Прокси = ПолучитьПрокси();
	Соединение = Новый HTTPСоединение(Сервер,,,,Прокси,,Новый ЗащищенноеСоединениеOpenSSL);
	Запрос = Новый HTTPЗапрос(); 
	
	Если ЗначениеЗаполнено(ИмяФайлаОтправки) Тогда
		
		//АдресФайла = СтруктураСообщения.text;
		//СтруктураСообщения.удалить("text");
		Команда = "sendDocument";
		
		Boundary = СтрЗаменить(Строка(Новый УникальныйИдентификатор()),"-","");
		
		Запрос.Заголовки.Вставить("Content-Type","multipart/form-data; boundary="+Boundary);
		//Запрос.Заголовки.Вставить("Connection", "keep-alive"); 
		
		ИмяФайлаДляЗапроса  = ПолучитьТектсФайлаОтправки(Boundary,ИмяФайлаОтправки,СтруктураСообщения,ЗаголовокФайла);
		
		//Запрос.Заголовки.Вставить("Content-Length", Формат(СтрДлина(ТелоОтправки),"ЧГ=0"));
		
		Запрос.УстановитьИмяФайлаТела(ИмяФайлаДляЗапроса);
		
		
	Иначе 
		
		Команда = "sendMessage";
		СтрокаПоПараметрам = ПолучитьСтрокуПоПараметрамЖСОН(СтруктураСообщения);
		Запрос.Заголовки.Вставить("Content-Type","application/json");
		
		//Запрос.УстановитьТелоИзСтроки(СтрокаПоПараметрам,,ИспользованиеByteOrderMark.НеИспользовать);
		Запрос.УстановитьТелоИзСтроки(СтрокаПоПараметрам,"CESU-8");	
		
	КонецЕсли;
	
	Ресурс = "bot"+КлючАПИ+"/"+Команда; 
	Запрос.АдресРесурса = Ресурс; 
	
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	Запрос = Неопределено;
	Соединение= Неопределено;
	Если ЗначениеЗаполнено(ИмяФайлаОтправки) Тогда
		УдалитьФайлы(ИмяФайлаОтправки);
	КонецЕсли;
	
	ОтветСоотв = ПрочитатьЖСОН(Ответ.ПолучитьТелоКакСтроку());

	ok = ОтветСоотв.Получить("ok");
	
	Если ok = Ложь Тогда
		Сообщить(ОтветСоотв["description"]);
	КонецЕсли;
	
	Соединение = Неопределено;
	
КонецПроцедуры

Функция ПолучитьСтрокуПоПараметрам(СтруктураПараметров)
	
	ИтоговаяСтрока = "";
	
	Если не ЗначениеЗаполнено(СтруктураПараметров) Тогда
		
		Возврат ИтоговаяСтрока;
		
	КонецЕсли;
	
	Для Каждого стр из СтруктураПараметров Цикл 
		
		Если НЕ ЗначениеЗаполнено(стр.Значение) Тогда
			Продолжить;
		КонецЕсли;
		
		СимволРазделителя = ?(ЗначениеЗаполнено(ИтоговаяСтрока),"&","?");		
		
		ЗначениеПараметра = СокрЛП(стр.Значение);
		ЗначениеПараметра = КодироватьСтроку(ЗначениеПараметра,СпособКодированияСтроки.КодировкаURL);
		ИтоговаяСтрока= ИтоговаяСтрока+ СимволРазделителя+ СокрЛП(стр.ключ)+"="+ЗначениеПараметра;
		
	КонецЦикла;
	
	
	Возврат ИтоговаяСтрока;
	
КонецФункции

Функция ПолучитьСтрокуПоПараметрамЖСОН(СтруктураПараметров)
	
	ИтоговаяСтрока = "";
	
	Если не ЗначениеЗаполнено(СтруктураПараметров) Тогда
		
		Возврат ИтоговаяСтрока;
		
	КонецЕсли;
	
	ИтоговаяСтрока = ЗаписатьЖСОН(СтруктураПараметров);
	
	Возврат ИтоговаяСтрока;
	
КонецФункции

Функция ПолучитьТектсФайлаОтправки(Boundary,ИмяФайлаДанных,СтруктураСообщения,Знач ЗаголовокФайла)
	
	Итог = "";
	Если не ЗначениеЗаполнено(ЗаголовокФайла) Тогда
		ЗаголовокФайла = "empty";
	КонецЕсли;
	
	//ИмяФайлаДанных = СтруктураСообщения.text;
	СтруктураСообщения.Удалить("text");
	Разделитель = Символы.ПС;
	для Каждого стр из СтруктураСообщения Цикл 
		Итог = Итог	+ "--" + Boundary+Разделитель;
		Итог = Итог	+ "Content-Disposition: form-data; name="""+стр.Ключ+""""+Разделитель;
		Итог = Итог + Символы.ПС;
		ЗначениеПараметра =  стр.Значение;
		Если ТипЗнч(ЗначениеПараметра) = Тип("Структура") Тогда
			ЗначениеПараметра =  ПолучитьСтрокуПоПараметрамЖСОН(ЗначениеПараметра);
		КонецЕсли;
		Итог = Итог	+ ЗначениеПараметра+Разделитель;
	КонецЦикла;
	
	РасширениеФайла =ПолучитьРасширениеФайлаПотипуТабДок();
	
	ИмяОтправляемогоФайла = ЗаголовокФайла+"."+РасширениеФайла;
	Итог = Итог+"--" + Boundary+Разделитель;
	Итог = Итог+"Content-Disposition: form-data; name=""document""; filename="""+ИмяОтправляемогоФайла+""" "+Разделитель;
	Итог = Итог+"Content-Type: text/plain"+Разделитель;
	//Итог = Итог + Символы.ПС;
	
	ИмяФайлаНачала 		= ПолучитьИмяВременногоФайла("txt");
	ИмяИтоговогоФайла	= ПолучитьИмяВременногоФайла("txt");
	ИмяФайлаОкончания 	= ПолучитьИмяВременногоФайла("txt");
	
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайлаНачала,КодировкаТекста.ANSI);
	ЗаписьТекста.Закрыть();
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайлаНачала,КодировкаТекста.UTF8);
	ЗаписьТекста.ЗаписатьСтроку(Итог);
	ЗаписьТекста.Закрыть();
	
	МассивФайловОбъединения = Новый Массив;
	МассивФайловОбъединения.Добавить(ИмяФайлаНачала);
	МассивФайловОбъединения.Добавить(ИмяФайлаДанных);
	
	Итог = Разделитель+"--" + Boundary + "--";
	
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайлаОкончания,КодировкаТекста.ANSI);
	ЗаписьТекста.Закрыть();
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайлаОкончания,КодировкаТекста.UTF8);
	ЗаписьТекста.ЗаписатьСтроку(Итог);
	ЗаписьТекста.Закрыть();
	
	МассивФайловОбъединения.Добавить(ИмяФайлаОкончания);
	
	ОбъединитьФайлы(МассивФайловОбъединения,ИмяИтоговогоФайла);
	
	УдалитьФайлы(ИмяФайлаНачала);    
	УдалитьФайлы(ИмяФайлаОкончания);    
	
	
	Возврат ИмяИтоговогоФайла;
	
КонецФункции

#КонецОбласти

#Область СохранениеНастроек

Процедура ПрочитатьНастройки() Экспорт 
	
	КлючиОтбора = Новый Структура("КлючОбъекта,Пользователь","НастройкиОбменаТелеграмм","ОбщийПользователь");
	
	
	ВыборкаХранилища = ХранилищеОбщихНастроек.Выбрать(КлючиОтбора);
	
	Если ВыборкаХранилища.Следующий() Тогда 
		
		ЗагрузитьВОбъект(ВыборкаХранилища.Настройки);
		
	Иначе 
		
		МакетПоУмолчанию = ПолучитьМакет("НастройкиПоУмолчанию");
		Настройки = ЗначениеИзСтрокиВнутр(МакетПоУмолчанию.ПолучитьТекст());
		ЗагрузитьВОбъект(Настройки);
		ЗаписатьНастройки();
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьНастройки() Экспорт 
	
	ОписаниеНастройки = Новый ОписаниеНастроек;
	ОписаниеНастройки.Представление = "Настройки обработки";
	
	ХранилищеОбщихНастроек.Сохранить("НастройкиОбменаТелеграмм",,ПолучитьСтруктуруНастроек(),ОписаниеНастройки, "ОбщийПользователь");
	
КонецПроцедуры

Функция ПолучитьСтруктуруНастроек() Экспорт 
	
	СтруктураРеквизитов = Новый Структура;
	СтруктураТабличныхЧастей = Новый Структура;
	
	ЭтиМетаданные = ЭтотОбъект.Метаданные();
	Для Каждого стр из ЭтиМетаданные.Реквизиты Цикл 
		СтруктураРеквизитов.Вставить(стр.Имя,ЭтотОбъект[стр.Имя]);
	КонецЦикла;
	
	СтруктураНастроек = Новый Структура;
	СтруктураНастроек.Вставить("Реквизиты",СтруктураРеквизитов);
	
	Возврат СтруктураНастроек;
	
КонецФункции

Функция ЗагрузитьВОбъект(СтруктураНастроек) Экспорт 
	
	Для Каждого стр из СтруктураНастроек.Реквизиты Цикл 
		
		Попытка
			
			ЭтотОбъект[стр.Ключ] =стр.Значение; 
		Исключение
			Сообщить("Ошибка загрузки настроек "+ОписаниеОшибки());
		КонецПопытки;
		
	КонецЦикла;
	
	Если НЕ СтруктураНастроек.Свойство("ТабличныеЧасти") Тогда 
		Возврат Истина;
	КонецЕсли;
		
	Для Каждого стр из СтруктураНастроек.ТабличныеЧасти Цикл 
		Попытка
			
			ЭтотОбъект[стр.Ключ].Загрузить(стр.Значение);
		Исключение
			Сообщить("Ошибка загрузки настроек "+ОписаниеОшибки());
		КонецПопытки;
	КонецЦикла;
	
КонецФункции

#КонецОбласти 

#Область ОбщиеФункции         

Функция ПолучитьДатуИзСтроки(Стр) 
	
	Д = Дата("00010101000000");
	
	Если ПустаяСтрока(Стр) Тогда
		Возврат Д;
	КонецЕсли;
	
	Если Найти(Стр,".") > 0 Тогда
		
		Если Найти(Стр,":") > 0 И Найти(Стр," ") > 0 Тогда 
			М = РазложитьСтрокуВМассивПодстрок(Стр," ");
			Возврат ПолучитьДатуИзСтроки(М[0]);
		КонецЕсли;
		
		М = РазложитьСтрокуВМассивПодстрок(Стр,".");
		
	ИначеЕсли Найти(Стр,"/")>0 Тогда
		
		М = РазложитьСтрокуВМассивПодстрок(Стр,"/");
		
	ИначеЕсли Найти(Стр,",")>0 Тогда
		
		М = РазложитьСтрокуВМассивПодстрок(Стр,",");
		
	ИначеЕсли Найти(Стр,"-")>0 Тогда
		
		М = РазложитьСтрокуВМассивПодстрок(Стр,"-");
		
	КонецЕсли; 
	
	Попытка
		
		Если М.Количество() = 3 Тогда //"01.02.13" или "01.02.2013"
			Год = ?(СтрДлина(М[2]) = 2,2000 + М[2],М[2]);
			Д = Дата(Год,М[1],М[0]);
		ИначеЕсли М.Количество() = 2 Тогда //"02.13" или "02.2013";
			Год = ?(СтрДлина(М[1]) = 2,2000 + М[1],М[1]);
			Д = Дата(Год,М[0],1);
		КонецЕсли;
		
	Исключение
	КонецПопытки; 
	
	Возврат Д; 
	
КонецФункции

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	
	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная));
	
КонецФункции // ПолучитьОписаниеТиповСтроки()

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт
	
	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);
	
КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));
	
КонецФункции // ПолучитьОписаниеТиповДаты()


// Разбивает строку на несколько строк по разделителю. Разделитель может иметь любую длину.
//
// Параметры:
//  Строка                 - Строка - текст с разделителями;
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ;
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     - для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат.
//     - если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//
//
// Возвращаемое значение:
//  Массив - массив строк.
//
// Примеры:
//  РазложитьСтрокуВМассивПодстрок(",один,,два,", ",") - возвратит массив из 5 элементов, три из которых  - пустые строки;
//  РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина) - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок(" один   два  ", " ") - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок("") - возвратит пустой массив;
//  РазложитьСтрокуВМассивПодстрок("",,Ложь) - возвратит массив с одним элементом "" (пустой строкой);
//  РазложитьСтрокуВМассивПодстрок("", " ") - возвратит массив с одним элементом "" (пустой строкой);
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено) Экспорт
	
	Результат = Новый Массив;
	
	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

#КонецОбласти 

МассивДаНет = Новый Массив;
МассивДаНет.Добавить("Истина");
МассивДаНет.Добавить("Ложь");

ЗаполнитьМассивСтандартногоПериода();